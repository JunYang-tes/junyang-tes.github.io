<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.2" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Qianba, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.2" />






<meta property="og:type" content="website">
<meta property="og:title" content="Blogs">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Blogs">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Blogs">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/"/>





  <title>Blogs</title>
  














</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Blogs</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/10/28/6.generic/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Qianba">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Blogs">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/10/28/6.generic/" itemprop="url">6.泛型</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-10-28T00:00:00+08:00">
                2017-10-28
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/翻译/" itemprop="url" rel="index">
                    <span itemprop="name">翻译</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/翻译/编程语言/" itemprop="url" rel="index">
                    <span itemprop="name">编程语言</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/翻译/编程语言/TypeScript/" itemprop="url" rel="index">
                    <span itemprop="name">TypeScript</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>软件工程活动中的一个主要方面是构建组件，这些组件不仅仅是有定义好的API，也要是可复用的。那些对于今天的数据是可用的，对于将来的数据也是可用的组件，将在构建大型软件系统时给你最大的灵活性。<br>在C#或Java这样的语言中，一个主要的功能就是用<code>泛型</code>来创建可复用的组件。<code>泛型</code>表示这些组件可用在许多不同的数据类型上，尔不是单一的数据类型。这就允许用户在这些组件里面使用自己的数据类型。</p>
<h1 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World"></a>Hello World</h1><p>让我们写一个泛型版的<code>Hello World</code>: ID 函数。ID函数指的是一种你给它什么它就返回给你什么的函数，就像<code>echo</code>命令一样。<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">identity</span>(<span class="params">arg: <span class="built_in">number</span></span>): <span class="title">number</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> arg;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>或者，我们可以使用<code>any</code>类型:<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">identity</span>(<span class="params">arg: <span class="built_in">any</span></span>): <span class="title">any</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> arg;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里实际上该用泛型，但是用了<code>any</code>,这会导致函数返回<code>any</code> 类型而丢失掉了类型信息。例如，传入了一个<code>number</code>类型，对于返回的类型却只知道它是<code>any</code>(注:从而失去了类型检查和进一步的类型推导)。</p>
<p>所以，我们需要一种捕获类型的方法，然后我们可用这种方法了标示返回类型。在这里，我们使用<code>类型变量</code>——一种特殊的变量为类型而生而不是为值而生。<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">identity</span>&lt;<span class="title">T</span>&gt;(<span class="params">arg:T</span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> arg</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>现在我们给Id函数加入了类型变量<code>T</code>。这个<code>T</code>让我们可以捕获用户提供的类型(例如<code>number</code>)，所以我们就可以使用这个类型。在这里，我们把<code>T</code>用做返回值类型。<br><!--
 On inspection, we can now see the same type is used for the argument and the return type. This allows us to traffic that type information in one side of the function and out the other.
 --></p>
<p> 我们说这个版本的id函数是个泛型函数，应为它可以用在很多类型上。和用<code>any</code>不同，它和<code>number</code>类型的哪个id函数一样是精准的(如，不会丢失类型信息)。</p>
<p> 一旦我们写好了泛型函数，我们有两种调用它的方式。第一种是传递所有的参数给它，包括类型参数:</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> output = identity&lt;<span class="built_in">string</span>&gt;(<span class="string">"myOutput"</span>)</div></pre></td></tr></table></figure>
<p>这里，我们明确的指定了T为<code>string</code>，其作为调用函数的一个类型参数，需用用尖括号括起来而不是圆括号。<br>第二种方式更为通用，即使用<code>类型推断</code>，即我们让编译器根据我们传入的类型自行设置<code>T</code>的值。<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> output = identity(<span class="string">"myString"</span>)</div></pre></td></tr></table></figure></p>
<p>注意，我们没有用尖括号来明确指明类型参数，编译器根据<code>&quot;myString&quot;</code>来决定<code>T</code>的值。尽管类型参数的自动推断可以使代码更短，可读性更强，但是有些复杂的情况下编译器不能推断出泛型的类型，这时就需要你明确指定泛型的类型。</p>
<h1 id="使用泛型类型变量"><a href="#使用泛型类型变量" class="headerlink" title="使用泛型类型变量"></a>使用泛型类型变量</h1><p>当你使用泛型时你会注意到当你创建像<code>identity</code>这样的泛型函数的时候，编译器会确保你在函数体内正确的使用了泛型。即，你实际应该把看做是所有类型。<br>如果我们想在函数体内把<code>arg</code>的<code>length</code>输出出来，会发生什么呢? 我们可能会这样写:<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">loggingIdentity</span>&lt;<span class="title">T</span>&gt;(<span class="params">arg:T</span>):<span class="title">T</span></span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(arg.length);</div><div class="line">    <span class="keyword">return</span> arg;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如果我们这样做，编译器会报告一个错误，即我们使用了<code>arg</code>的<code>length</code>成员，但是我们没说过<code>arg</code>有这样一个成员。上面说过，你应该把T看成是所有类型，所以可能传进来的<code>arg</code>是一个数字，那么它是没有<code>length</code>属性的。</p>
<p>这里我们实际上是希望这个函数接受<code>T</code>数组而不是T。如果<code>arg</code>是<code>T</code>的数组，那么就可以访问<code>.length</code>属性了。<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">loggingIdentity</span>&lt;<span class="title">T</span>&gt;(<span class="params">arg: T[]</span>): <span class="title">T</span>[] </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(arg.length);  <span class="comment">// Array has a .length, so no more error</span></div><div class="line">    <span class="keyword">return</span> arg;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>现在你可以把这个函数解读为:一个拥有类型参数<code>T</code>以及函数参数<code>arg</code>—— 为数组T类型 ——并返回<code>T</code>数组类型的泛型函数。如果我们传入一个数字数组，我们会得到一个返回的数字数组，那么<code>T</code>为<code>number</code>。<!-- This allows us to use our generic type variable `T` as part of the types we're working with,rather than the whole type,giving us greater flexibility --><br>这让我们可以把泛型类型<code>T</code>作为所有我们用到的类型的一个部分，而不是所有类型。这样给我们更多的灵活性。<br>对上面的例子我们也可使用下面的形式:<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">loggingIdentity</span>&lt;<span class="title">T</span>&gt;(<span class="params">arg: <span class="built_in">Array</span>&lt;T&gt;</span>): <span class="title">Array</span>&lt;<span class="title">T</span>&gt; </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(arg.length);  <span class="comment">// Array has a .length, so no more error</span></div><div class="line">    <span class="keyword">return</span> arg;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>你也许很熟悉这种写法，在下节中，我们将会讨论如何创建类似于<code>Array&lt;T&gt;</code>这样的泛型。</p>
<h1 id="泛形类型"><a href="#泛形类型" class="headerlink" title="泛形类型"></a>泛形类型</h1><p>在前面几个小节中我们创建了一个泛型函数,它可又接受一些类型，在这节中我们将探索函数自身的类型以及如何创建泛型接口。<br>泛型函数的类型和非泛型函数的类型是类似的，需把泛型参数写在最前面。<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">identity</span>&lt;<span class="title">T</span>&gt;(<span class="params">arg: T</span>): <span class="title">T</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> arg;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> myIdentity: &lt;T&gt;<span class="function">(<span class="params">arg: T</span>) =&gt;</span> T = identity;</div></pre></td></tr></table></figure></p>
<p>在类型中，我们也可以使用不同的泛型参数名，只要泛型参数的数量和用的位置是对的就可以。<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">identity</span>&lt;<span class="title">T</span>&gt;(<span class="params">arg: T</span>): <span class="title">T</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> arg;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> myIdentity: &lt;U&gt;<span class="function">(<span class="params">arg: U</span>) =&gt;</span> U = identity;</div></pre></td></tr></table></figure></p>
<p>我们也可用对象字面量的方式来表示泛型函数得类型:<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">identity</span>&lt;<span class="title">T</span>&gt;(<span class="params">arg: T</span>): <span class="title">T</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> arg;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> myIdentity: &#123;&lt;T&gt;(arg: T): T&#125; = identity;</div></pre></td></tr></table></figure></p>
<p>我们可以把这个例子写成一个接口。<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">interface</span> GenericIdentityFn &#123;</div><div class="line">    &lt;T&gt;(arg: T): T;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">identity</span>&lt;<span class="title">T</span>&gt;(<span class="params">arg: T</span>): <span class="title">T</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> arg;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> myIdentity: GenericIdentityFn = identity;</div></pre></td></tr></table></figure></p>
<p>或者，我们可以把泛型参数做为整个接口得泛型参数。这样，该接口的所有成员都可以使用该泛型参数。<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">interface</span> GenericIdentityFn&lt;T&gt; &#123;</div><div class="line">    (arg: T): T;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">identity</span>&lt;<span class="title">T</span>&gt;(<span class="params">arg: T</span>): <span class="title">T</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> arg;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> myIdentity: GenericIdentityFn&lt;<span class="built_in">number</span>&gt; = identity;</div></pre></td></tr></table></figure></p>
<p>注意，我们的例子变的有点不同了。<br>&lt;!–<br>. Instead of describing a generic function, we now have a non-generic function signature that is a part of a generic type. When we use GenericIdentityFn, we now will also need to specify the corresponding type argument (here: number), effectively locking in what the underlying call signature will use. Understanding when to put the type parameter directly on the call signature and when to put it on the interface itself will be helpful in describing what aspects of a type are generic.</p>
<p>In addition to generic interfaces, we can also create generic classes. Note that it is not possible to create generic enums and namespaces.<br>–&gt;</p>
<h1 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h1><p>泛型类和浮现接口有类似的结构。泛型类在类名后面有一个泛型参数表。<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> GenericNumber&lt;T&gt; &#123;</div><div class="line">    zeroValue: T;</div><div class="line">    add: <span class="function">(<span class="params">x: T, y: T</span>) =&gt;</span> T;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> myGenericNumber = <span class="keyword">new</span> GenericNumber&lt;<span class="built_in">number</span>&gt;();</div><div class="line">myGenericNumber.zeroValue = <span class="number">0</span>;</div><div class="line">myGenericNumber.add = <span class="function"><span class="keyword">function</span>(<span class="params">x, y</span>) </span>&#123; <span class="keyword">return</span> x + y; &#125;;</div></pre></td></tr></table></figure></p>
<!--This is a pretty literal use of the GenericNumber class, but you may have noticed that nothing is restricting it to only use the number type. We could have instead used string or even more complex objects.-->
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> stringNumeric = <span class="keyword">new</span> GenericNumber&lt;<span class="built_in">string</span>&gt;();</div><div class="line">stringNumeric.zeroValue = <span class="string">""</span>;</div><div class="line">stringNumeric.add = <span class="function"><span class="keyword">function</span>(<span class="params">x, y</span>) </span>&#123; <span class="keyword">return</span> x + y; &#125;;</div><div class="line"></div><div class="line">alert(stringNumeric.add(stringNumeric.zeroValue, <span class="string">"test"</span>));</div></pre></td></tr></table></figure>
<p>就像使用接口一样，在类上使用泛型参数可让类中的的属性或方法可以使用这个泛型类型。</p>
<p>在<a href="">类</a>这章描述过，类的类型有两种方面:类方面和实例方面。泛型类的泛型只在其实例中可用。也就是说，静态方法不能访问泛型类的浮现参数。</p>
<h1 id="对泛型的约束"><a href="#对泛型的约束" class="headerlink" title="对泛型的约束"></a>对泛型的约束</h1><p>如果你还记得前面的例子，你也许希望你的泛型函数中的泛型类型只实用于一部分的类型。对于<code>loggingIdentity</code>这个例子中，我们希望能访问arg的length属性，但是编译器无法保证每个类型都有一个length属性，所以它会给出一个警告。<br><!--
If you remember from an earlier example, you may sometimes want to write a generic function that works on a set of types where you have some knowledge about what capabilities that set of types will have. In our loggingIdentity example, we wanted to be able to access the .length property of arg, but the compiler could not prove that every type had a .length property, so it warns us that we can’t make this assumption.
--><br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">loggingIdentity</span>&lt;<span class="title">T</span>&gt;(<span class="params">arg: T</span>): <span class="title">T</span> </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(arg.length);  <span class="comment">// Error: T doesn't have .length</span></div><div class="line">    <span class="keyword">return</span> arg;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<!--
Instead of working with any and all types, we’d like to constrain this function to work with any and all types that also have the .length property. As long as the type has this member, we’ll allow it, but it’s required to have at least this member. To do so, we must list our requirement as a constraint on what T can be.
-->
<p>除了使用<code>any</code>类型或所有类型，我们希望这个函数使用那些带有<code>.length</code>属性的类型。只要某类型有<code>.length</code>属性，我们就允许它被传递到函数中，而且只是要求这个属性是必须要有的。为了做到这点，我们必须对<code>T</code>作一些限定。</p>
<!--
To do so, we’ll create an interface that describes our constraint. Here, we’ll create an interface that has a single .length property and then we’ll use this interface and the extends keyword to denote our constraint:
-->
<p>为了对<code>T</code>作限定，我们使用接口来描述我们的限定。这里我们创建一个拥有单一属性<code>length</code>的接口，并使用这个接口和<code>extends</code>关键字来说明我们的限制。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">interface</span> Lengthwise &#123;</div><div class="line">    length: <span class="built_in">number</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">loggingIdentity</span>&lt;<span class="title">T</span> <span class="title">extends</span> <span class="title">Lengthwise</span>&gt;(<span class="params">arg: T</span>): <span class="title">T</span> </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(arg.length);  <span class="comment">// Now we know it has a .length property, so no more error</span></div><div class="line">    <span class="keyword">return</span> arg;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>因为现在该泛型函数被限制了泛型的类型，那么不再可用任意类型作这个泛型了。<br><!--
Because the generic function is now constrained, it will no longer work over any and all types:
--><br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">loggingIdentity(<span class="number">3</span>);  <span class="comment">// Error, number doesn't have a .length property</span></div></pre></td></tr></table></figure></p>
<p>除非我们传递一个有<code>length</code>属性的东西给它。<br><!--
Instead, we need to pass in values whose type has all the required properties:
--><br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">loggingIdentity(&#123;length: <span class="number">10</span>, value: <span class="number">3</span>&#125;);</div></pre></td></tr></table></figure></p>
<h2 id="在类型参数中使用限定"><a href="#在类型参数中使用限定" class="headerlink" title="在类型参数中使用限定"></a>在类型参数中使用限定</h2><!--
You can declare a type parameter that is constrained by another type parameter. For example, here we’d like to get a property from an object given its name. We’d like to ensure that we’re not accidentally grabbing a property that does not exist on the obj, so we’ll place a constraint between the two types:
-->
<p>你可用一个类型参数来限定另一个类型参数。例如，我们想从一个给定的名字来访问一个对象的属性。我们希望能确保我们不会意外的访问了那些不存在的属性。所以我们在这两个泛型类型中应用一个限定。<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getProperty</span>&lt;<span class="title">T</span>, <span class="title">K</span> <span class="title">extends</span> <span class="title">keyof</span> <span class="title">T</span>&gt;(<span class="params">obj: T, key: K</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> obj[key];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> x = &#123; a: <span class="number">1</span>, b: <span class="number">2</span>, c: <span class="number">3</span>, d: <span class="number">4</span> &#125;;</div><div class="line"></div><div class="line">getProperty(x, <span class="string">"a"</span>); <span class="comment">// okay</span></div><div class="line">getProperty(x, <span class="string">"m"</span>); <span class="comment">// error: Argument of type 'm' isn't assignable to 'a' | 'b' | 'c' | 'd'.</span></div></pre></td></tr></table></figure></p>
<h2 id="在泛型中使用类类型"><a href="#在泛型中使用类类型" class="headerlink" title="在泛型中使用类类型"></a>在泛型中使用类类型</h2><p>When creating factories in TypeScript using generics, it is necessary to refer to class types by their constructor functions. For example,<br>当我们在工厂函数中使用泛型的时候，在其构造函数中引用类类型是有必要的。例如：<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">function create&lt;T&gt;(c: &#123;new(): T; &#125;): T &#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> c();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<!--
A more advanced example uses the prototype property to infer and constrain relationships between the constructor function and the instance side of class types.
-->
<p>下面的例子演示了使用原型来引用和限定构造函数和类实例之间的关系。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> BeeKeeper &#123;</div><div class="line">    hasMask: <span class="built_in">boolean</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">class</span> ZooKeeper &#123;</div><div class="line">    nametag: <span class="built_in">string</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">class</span> Animal &#123;</div><div class="line">    numLegs: <span class="built_in">number</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">class</span> Bee <span class="keyword">extends</span> Animal &#123;</div><div class="line">    keeper: BeeKeeper;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">class</span> Lion <span class="keyword">extends</span> Animal &#123;</div><div class="line">    keeper: ZooKeeper;</div><div class="line">&#125;</div><div class="line"></div><div class="line">function createInstance&lt;A extends Animal&gt;(c: new () =&gt; A): A &#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> c();</div><div class="line">&#125;</div><div class="line"></div><div class="line">createInstance(Lion).keeper.nametag;  <span class="comment">// typechecks!</span></div><div class="line">createInstance(Bee).keeper.hasMask;   <span class="comment">// typechecks!</span></div></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/10/28/5.function/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Qianba">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Blogs">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/10/28/5.function/" itemprop="url">5.函数</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-10-28T00:00:00+08:00">
                2017-10-28
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/翻译/" itemprop="url" rel="index">
                    <span itemprop="name">翻译</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/翻译/编程语言/" itemprop="url" rel="index">
                    <span itemprop="name">编程语言</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/翻译/编程语言/TypeScript/" itemprop="url" rel="index">
                    <span itemprop="name">TypeScript</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>函数是任何一个JavaScript程序中的基本构建单位。用它们你可以构建抽象层、模拟类、隐藏信息和模块化。在TypeScript中，尽管本来就有类、名字空间和模块这些东西，函数依然伴演了描述<code>如何做某些事</code>的关键角色。TypeScript也在标准的JavaScript函数上添加了一些东西来使它们更易于使用。</p>
<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><p>和JavaScript一样，TypeScript可创建命名的函数和匿名的函数。这允许你选择最合适你的应用的方式，是在创建一个API的函数列表还是一个传递给另一个函数的一次性函数(a one-off function to hand off to another function).<br>下面的例子简要的演示了JavaScript中这两这方式:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Named function</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x, y</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> x + y;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// Anonymous function</span></div><div class="line"><span class="keyword">let</span> myAdd = <span class="function"><span class="keyword">function</span>(<span class="params">x, y</span>) </span>&#123; <span class="keyword">return</span> x + y; &#125;;</div></pre></td></tr></table></figure></p>
<p>就像在JavaScript中一样，函数可以引用函数体外部的变量，这叫做<code>变量捕获</code>。<br><!--While understanding how this works, and the trade-offs when using this technique, are outside of the scope of this article, having a firm understanding how this mechanic is an important piece of working with JavaScript and TypeScript.--><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> z = <span class="number">100</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">addToZ</span>(<span class="params">x, y</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> x + y + z;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="函数类型"><a href="#函数类型" class="headerlink" title="函数类型"></a>函数类型</h1><h2 id="添加类型"><a href="#添加类型" class="headerlink" title="添加类型"></a>添加类型</h2><p>让我们给前面的例子加上函数类型:<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>): <span class="title">number</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> x + y;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> myAdd = <span class="function"><span class="keyword">function</span>(<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>): <span class="title">number</span> </span>&#123; <span class="keyword">return</span> x + y; &#125;;</div></pre></td></tr></table></figure></p>
<p>我们能为函数的每个参数添加类型、给函数自身添加类型以及给函数的返回值添加类型。TypeScript可以通过返回语句推断出返回值的类型，所以在大多数情况下，我们可以不用指定返回值的类型。</p>
<h2 id="写函数类型"><a href="#写函数类型" class="headerlink" title="写函数类型"></a>写函数类型</h2><p>现在我们只定义了函数，让我们写出完整的函数类型:<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> myAdd: <span class="function">(<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">number</span> =</div><div class="line">    <span class="function"><span class="keyword">function</span>(<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>): <span class="title">number</span> </span>&#123; <span class="keyword">return</span> x + y; &#125;;</div></pre></td></tr></table></figure></p>
<p>一个函数类型有两个部分:参数的类型和返回值的类型。当要写出完整的函数的类型，这两个部分都是必要的。我们像写函数的参数列表那样写出参数的类型，给每个参数一个名字和一个类型。这个名字只为了增加代码的可读性，我们可写成<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> myAdd: <span class="function">(<span class="params">baseValue: <span class="built_in">number</span>, increment: <span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">number</span> =</div><div class="line">    <span class="function"><span class="keyword">function</span>(<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>): <span class="title">number</span> </span>&#123; <span class="keyword">return</span> x + y; &#125;;</div></pre></td></tr></table></figure></p>
<p>只要参数的类型和函数参数的类型是一致的，不管名字是否一致都是可以的。<br>第二部分是返回值类型。我们使用了一个胖箭头(=&gt;)来表式其后是返回值的类型。如前面所说，这是函数类型中必不可少的一部分，所以如果一个函数不返回值你需要使用void来表示。<br>注意，函数类型仅由参数类型和返回值类型构成，而不包括捕获的变量的类型。结果是，捕获的变量作为了函数的隐性状态。</p>
<h2 id="推断类型"><a href="#推断类型" class="headerlink" title="推断类型"></a>推断类型</h2><p>你也许注意到了，如果你省略了等号一边的类型，TypeScript的编译器可以猜测出类型。<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// myAdd has the full function type</span></div><div class="line"><span class="keyword">let</span> myAdd = <span class="function"><span class="keyword">function</span>(<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>): <span class="title">number</span> </span>&#123; <span class="keyword">return</span>  x + y; &#125;;</div><div class="line"></div><div class="line"><span class="comment">// The parameters 'x' and 'y' have the type number</span></div><div class="line"><span class="keyword">let</span> myAdd: <span class="function">(<span class="params">baseValue: <span class="built_in">number</span>, increment: <span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">number</span> =</div><div class="line">    <span class="function"><span class="keyword">function</span>(<span class="params">x, y</span>) </span>&#123; <span class="keyword">return</span> x + y; &#125;;</div></pre></td></tr></table></figure></p>
<p>这叫作<code>上下文类型</code>，类型推断的一种形似。这可以减少和类型相关的工作量。</p>
<h2 id="可选和默认参数"><a href="#可选和默认参数" class="headerlink" title="可选和默认参数"></a>可选和默认参数</h2><p>TypeScript会假设每个参数都是必须的。在并不意味着不能传递<code>null</code>或<code>undefined</code>给它，而是在每个函数被调用的时候，编译器会检察用户是否为每个参数提拱了值。编译器也会假设这些参数就刚好是要传递到函数中的参数(注:数量假设)。简而言之，给出的参数的个数要和函数期望的参数的个数相匹配。<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">buildName</span>(<span class="params">firstName: <span class="built_in">string</span>, lastName: <span class="built_in">string</span></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> firstName + <span class="string">" "</span> + lastName;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> result1 = buildName(<span class="string">"Bob"</span>);                  <span class="comment">// error, too few parameters</span></div><div class="line"><span class="keyword">let</span> result2 = buildName(<span class="string">"Bob"</span>, <span class="string">"Adams"</span>, <span class="string">"Sr."</span>);  <span class="comment">// error, too many parameters</span></div><div class="line"><span class="keyword">let</span> result3 = buildName(<span class="string">"Bob"</span>, <span class="string">"Adams"</span>);         <span class="comment">// ah, just right</span></div></pre></td></tr></table></figure></p>
<p>在JavaScript中，每个参数都是可选的，用户可能会省略其中的一些参数，如果参数被省略了那么该参数就是<code>undefined</code>。在TypeScript中可以通过在参数名末尾添加<code>?</code>来使用这一功能。比如，如果第二个参数是可选的:<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">buildName</span>(<span class="params">firstName: <span class="built_in">string</span>, lastName?: <span class="built_in">string</span></span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (lastName)</div><div class="line">        <span class="keyword">return</span> firstName + <span class="string">" "</span> + lastName;</div><div class="line">    <span class="keyword">else</span></div><div class="line">        <span class="keyword">return</span> firstName;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> result1 = buildName(<span class="string">"Bob"</span>);                  <span class="comment">// works correctly now</span></div><div class="line"><span class="keyword">let</span> result2 = buildName(<span class="string">"Bob"</span>, <span class="string">"Adams"</span>, <span class="string">"Sr."</span>);  <span class="comment">// error, too many parameters</span></div><div class="line"><span class="keyword">let</span> result3 = buildName(<span class="string">"Bob"</span>, <span class="string">"Adams"</span>);         <span class="comment">// ah, just right</span></div></pre></td></tr></table></figure></p>
<p>可选参数必须要在必选参数后面声明。<br>在TypeScript中，我们也可以参数设置一个预设值，如果调用者没有提拱该参数(或提拱了一个<code>undefined</code>)，那么该参数的值就是预设值。这被叫做<code>默认参数</code>.<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">function buildName(firstName: string, lastName = "Smith") &#123;</div><div class="line">    <span class="keyword">return</span> firstName + <span class="string">" "</span> + lastName;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> result1 = buildName(<span class="string">"Bob"</span>);                  <span class="comment">// works correctly now, returns "Bob Smith"</span></div><div class="line"><span class="keyword">let</span> result2 = buildName(<span class="string">"Bob"</span>, <span class="literal">undefined</span>);       <span class="comment">// still works, also returns "Bob Smith"</span></div><div class="line"><span class="keyword">let</span> result3 = buildName(<span class="string">"Bob"</span>, <span class="string">"Adams"</span>, <span class="string">"Sr."</span>);  <span class="comment">// error, too many parameters</span></div><div class="line"><span class="keyword">let</span> result4 = buildName(<span class="string">"Bob"</span>, <span class="string">"Adams"</span>);         <span class="comment">// ah, just right</span></div></pre></td></tr></table></figure></p>
<p>默认参数被视作是可选参数，和可选参数一样，我们可以在调用函数的时候忽略它们。可选参数和默认参数的类型(注:指的是函数的类型)是共用的。<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">buildName</span>(<span class="params">firstName: <span class="built_in">string</span>, lastName?: <span class="built_in">string</span></span>) </span>&#123;</div><div class="line">    <span class="comment">// ...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>和</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">function buildName(firstName: string, lastName = "Smith") &#123;</div><div class="line">    <span class="comment">// ...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>的类型都是<code>(firstName:string,lastName?:string)=&gt;string</code>. <code>lastName</code>的默认在在类中是没有体现的，只留下该参数是可选的这一事实。<br>和原生可选参数不同，默认参数不需要声明在必须参数后面。<!--此时类型是什么样的?--> 。如果一个默认参数只必选参数之前，那我们需要明确的传递一个<code>undefined</code>给它。<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">function buildName(firstName = "Will", lastName: string) &#123;</div><div class="line">    <span class="keyword">return</span> firstName + <span class="string">" "</span> + lastName;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> result1 = buildName(<span class="string">"Bob"</span>);                  <span class="comment">// error, too few parameters</span></div><div class="line"><span class="keyword">let</span> result2 = buildName(<span class="string">"Bob"</span>, <span class="string">"Adams"</span>, <span class="string">"Sr."</span>);  <span class="comment">// error, too many parameters</span></div><div class="line"><span class="keyword">let</span> result3 = buildName(<span class="string">"Bob"</span>, <span class="string">"Adams"</span>);         <span class="comment">// okay and returns "Bob Adams"</span></div><div class="line"><span class="keyword">let</span> result4 = buildName(<span class="literal">undefined</span>, <span class="string">"Adams"</span>);     <span class="comment">// okay and returns "Will Adams"</span></div></pre></td></tr></table></figure></p>
<h2 id="Rest-参数"><a href="#Rest-参数" class="headerlink" title="Rest 参数"></a>Rest 参数</h2><p>必选，可选，默认参数有一个共同点:它们谈及的都是一个参数的情况。有时候你可能会想把多个参数”打包起来”，或者你压根就不知道函数实际上会接受到多少个参数。在JavaScript中，你可以使用<code>arguments</code>(注:JavaScript的魔术变量)来处理这种情况。<br>在TypeScript中，你可以把所有的参数收集到同一个变量中:<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">buildName</span>(<span class="params">firstName: <span class="built_in">string</span>, ...restOfName: <span class="built_in">string</span>[]</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> firstName + <span class="string">" "</span> + restOfName.join(<span class="string">" "</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> employeeName = buildName(<span class="string">"Joseph"</span>, <span class="string">"Samuel"</span>, <span class="string">"Lucas"</span>, <span class="string">"MacKinzie"</span>);</div></pre></td></tr></table></figure></p>
<p>(注:ES6也有这种语法)<br>Rest参数被视为一组可选参数，你可以传递任意多的参数都Rest参数。编译器会创建一个参数数组，其名字在<code>...</code>后指定。<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">buildName</span>(<span class="params">firstName: <span class="built_in">string</span>, ...restOfName: <span class="built_in">string</span>[]</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> firstName + <span class="string">" "</span> + restOfName.join(<span class="string">" "</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> buildNameFun: <span class="function">(<span class="params">fname: <span class="built_in">string</span>, ...rest: <span class="built_in">string</span>[]</span>) =&gt;</span> <span class="built_in">string</span> = buildName;</div></pre></td></tr></table></figure></p>
<h1 id="this"><a href="#this" class="headerlink" title="this"></a>this</h1><!--a rite of passage,必由之路-->
<p>学习如何使用<code>this</code>是学习JavaScript中的一条必经之路。TypeScript是JavaScript的超集，所以TypeScript的程序员也需要学习如何使用<code>this</code>以及指出什么时候this被错误的使用了。<br>幸运的是，TypeScript使用了一些技术来捕获<code>this</code>不正确的使用。如果你需要学习在JavaScript中如何使用<code>this</code>,请先阅读<a href="http://yehudakatz.com/2011/08/11/understanding-javascript-function-invocation-and-this/" target="_blank" rel="external">《理解JavaScript函数和this》</a>，该文介绍了<code>this</code>内部的东西，我们这里只介绍一些基础。</p>
<h2 id="this-和箭头函数"><a href="#this-和箭头函数" class="headerlink" title="this 和箭头函数"></a>this 和箭头函数</h2><p>在JavaScript中，当函数被调用的时候其中的<code>this</code>是可用的。这是一个强大的、灵活的特性，但其代价是总是需要知道函数正在执行的上下文是什么。这是十分具有迷惑性的，特别是在返回一个函数或以一个函数为参数的时候。<br>例如:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> deck = &#123;</div><div class="line">    suits: [<span class="string">"hearts"</span>, <span class="string">"spades"</span>, <span class="string">"clubs"</span>, <span class="string">"diamonds"</span>],</div><div class="line">    cards: <span class="built_in">Array</span>(<span class="number">52</span>),</div><div class="line">    createCardPicker: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">            <span class="keyword">let</span> pickedCard = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * <span class="number">52</span>);</div><div class="line">            <span class="keyword">let</span> pickedSuit = <span class="built_in">Math</span>.floor(pickedCard / <span class="number">13</span>);</div><div class="line"></div><div class="line">            <span class="keyword">return</span> &#123;<span class="attr">suit</span>: <span class="keyword">this</span>.suits[pickedSuit], <span class="attr">card</span>: pickedCard % <span class="number">13</span>&#125;;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> cardPicker = deck.createCardPicker();</div><div class="line"><span class="keyword">let</span> pickedCard = cardPicker();</div><div class="line"></div><div class="line">alert(<span class="string">"card: "</span> + pickedCard.card + <span class="string">" of "</span> + pickedCard.suit);</div></pre></td></tr></table></figure></p>
<p>注意，<code>createCardPicker</code>将返回一个函数。如果我们运行这个例子，我们会得到一个错误，而不是期望中的警告框。这是因为，createCardPicker返回的函数中的<code>this</code>是<code>window</code>而非<code>deck</code>对象。这是因为我们以<code>顶层非方法的语法</code>的方式在调用<code>cardPicker</code>(原注:在严格模式下，this会是undefined)。<br>我们可以通过确保function 绑定到正确的<code>this</code>的方式修正这个问题。这种情况下，无论这个函数多晚被调用，它总可以访问到deck对象。为了做到这点，我们可使用ES6的箭头函数，箭头函数会在函数被创建的时候捕获<code>this</code>。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> deck = &#123;</div><div class="line">    suits: [<span class="string">"hearts"</span>, <span class="string">"spades"</span>, <span class="string">"clubs"</span>, <span class="string">"diamonds"</span>],</div><div class="line">    cards: <span class="built_in">Array</span>(<span class="number">52</span>),</div><div class="line">    createCardPicker: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="comment">// <span class="doctag">NOTE:</span> the line below is now an arrow function, allowing us to capture 'this' right here</span></div><div class="line">        <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">            <span class="keyword">let</span> pickedCard = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * <span class="number">52</span>);</div><div class="line">            <span class="keyword">let</span> pickedSuit = <span class="built_in">Math</span>.floor(pickedCard / <span class="number">13</span>);</div><div class="line"></div><div class="line">            <span class="keyword">return</span> &#123;<span class="attr">suit</span>: <span class="keyword">this</span>.suits[pickedSuit], <span class="attr">card</span>: pickedCard % <span class="number">13</span>&#125;;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> cardPicker = deck.createCardPicker();</div><div class="line"><span class="keyword">let</span> pickedCard = cardPicker();</div><div class="line"></div><div class="line">alert(<span class="string">"card: "</span> + pickedCard.card + <span class="string">" of "</span> + pickedCard.suit);</div></pre></td></tr></table></figure></p>
<p>更进一步，如果你使用了<code>--noImplicitThis</code>选项，TypeScript会在你错误的使用this的时候给出一个警告。它会指出<code>this.suits[pickedSuit]</code>中的<code>this</code>是<code>any</code>类型的。</p>
<h2 id="this-参数"><a href="#this-参数" class="headerlink" title="this 参数"></a>this 参数</h2><p>不幸的是，<code>this.suits[pickedSuit]</code>的类型还是是<code>any</code>。这是因为<code>this</code>是来自于函数表达式中的对象字面量。你可以通过明确的指定一个<code>this</code>参数来修正这个问题。<code>this</code>参数是位于参数表中第一个参数的假参数。<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"><span class="keyword">this</span>: <span class="built_in">void</span></span>) </span>&#123;</div><div class="line">    <span class="comment">// make sure `this` is unusable in this standalone function</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>现在添加两个接口来使类型更加清晰和更易复用:<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">interface</span> Card &#123;</div><div class="line">    suit: <span class="built_in">string</span>;</div><div class="line">    card: <span class="built_in">number</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">interface</span> Deck &#123;</div><div class="line">    suits: <span class="built_in">string</span>[];</div><div class="line">    cards: <span class="built_in">number</span>[];</div><div class="line">    createCardPicker(<span class="keyword">this</span>: Deck): <span class="function"><span class="params">()</span> =&gt;</span> Card;</div><div class="line">&#125;</div><div class="line"><span class="keyword">let</span> deck: Deck = &#123;</div><div class="line">    suits: [<span class="string">"hearts"</span>, <span class="string">"spades"</span>, <span class="string">"clubs"</span>, <span class="string">"diamonds"</span>],</div><div class="line">    cards: <span class="built_in">Array</span>(<span class="number">52</span>),</div><div class="line">    <span class="comment">// <span class="doctag">NOTE:</span> The function now explicitly specifies that its callee must be of type Deck</span></div><div class="line">    createCardPicker: <span class="function"><span class="keyword">function</span>(<span class="params"><span class="keyword">this</span>: Deck</span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">            <span class="keyword">let</span> pickedCard = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * <span class="number">52</span>);</div><div class="line">            <span class="keyword">let</span> pickedSuit = <span class="built_in">Math</span>.floor(pickedCard / <span class="number">13</span>);</div><div class="line"></div><div class="line">            <span class="keyword">return</span> &#123;suit: <span class="keyword">this</span>.suits[pickedSuit], card: pickedCard % <span class="number">13</span>&#125;;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> cardPicker = deck.createCardPicker();</div><div class="line"><span class="keyword">let</span> pickedCard = cardPicker();</div><div class="line"></div><div class="line">alert(<span class="string">"card: "</span> + pickedCard.card + <span class="string">" of "</span> + pickedCard.suit);</div></pre></td></tr></table></figure></p>
<p>现在TypeScript知道<code>createCardPicker</code>需要在<code>Deck</code>对象上被调用，这表明<code>this</code>的<code>Deck</code>类型的而不是<code>any</code>，所以<code>--noImplicitThis</code>不会导致问题。</p>
<h2 id="回调中的this参数。"><a href="#回调中的this参数。" class="headerlink" title="回调中的this参数。"></a>回调中的<code>this</code>参数。</h2><!--
You can also run into errors with this in callbacks, when you pass functions to a library that will later call them. Because the library that calls your callback will call it like a normal function, this will be undefined. With some work you can use this parameters to prevent errors with callbacks too. First, the library author needs to annotate the callback type with this:
-->
<p>当你传递一个函数到一个库中，你也会在回调中遇到<code>this</code>的问题。因为这些库会将你的回调作为一个普通函数来调用，<code>this</code>就会是<code>undefined</code>. 你可用<code>this</code>参数来防止一些错误。首先，库的作者需要这样表示回调:<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">interface</span> UIElement &#123;</div><div class="line">    addClickListener(onclick: <span class="function">(<span class="params"><span class="keyword">this</span>: <span class="built_in">void</span>, e: Event</span>) =&gt;</span> <span class="built_in">void</span>): <span class="built_in">void</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>this: void means that addClickListener expects onclick to be a function that does not require a this type. Second, annotate your calling code with this:</p>
<p>class Handler {<br>    info: string;<br>    onClickBad(this: Handler, e: Event) {<br>        // oops, used this here. using this callback would crash at runtime<br>        this.info = e.message;<br>    }<br>}<br>let h = new Handler();<br>uiElement.addClickListener(h.onClickBad); // error!<br>With this annotated, you make it explicit that onClickBad must be called on an instance of Handler. Then TypeScript will detect that addClickListener requires a function that has this: void. To fix the error, change the type of this:</p>
<p>class Handler {<br>    info: string;<br>    onClickGood(this: void, e: Event) {<br>        // can’t use this here because it’s of type void!<br>        console.log(‘clicked!’);<br>    }<br>}<br>let h = new Handler();<br>uiElement.addClickListener(h.onClickGood);<br>Because onClickGood specifies its this type as void, it is legal to pass to addClickListener. Of course, this also means that it can’t use this.info. If you want both then you’ll have to use an arrow function:</p>
<p>class Handler {<br>    info: string;<br>    onClickGood = (e: Event) =&gt; { this.info = e.message }<br>}<br>This works because arrow functions don’t capture this, so you can always pass them to something that expects this: void. The downside is that one arrow function is created per object of type Handler. Methods, on the other hand, are only created once and attached to Handler’s prototype. They are shared between all objects of type Handler.</p>
<h1 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h1><!--JavaScript is inherently a very dynamic language. It’s not uncommon for a single JavaScript function to return different types of objects based on the shape of the arguments passed in.
-->
<p>JavaScript是一种非常“动态”的语言。JavaScript中函数根据传入的参数返回不同的对象是很常见的。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> suits = [<span class="string">"hearts"</span>, <span class="string">"spades"</span>, <span class="string">"clubs"</span>, <span class="string">"diamonds"</span>];</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">pickCard</span>(<span class="params">x</span>): <span class="title">any</span> </span>&#123;</div><div class="line">    <span class="comment">// Check to see if we're working with an object/array</span></div><div class="line">    <span class="comment">// if so, they gave us the deck and we'll pick the card</span></div><div class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> x == <span class="string">"object"</span>) &#123;</div><div class="line">        <span class="keyword">let</span> pickedCard = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * x.length);</div><div class="line">        <span class="keyword">return</span> pickedCard;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// Otherwise just let them pick the card</span></div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> x == <span class="string">"number"</span>) &#123;</div><div class="line">        <span class="keyword">let</span> pickedSuit = <span class="built_in">Math</span>.floor(x / <span class="number">13</span>);</div><div class="line">        <span class="keyword">return</span> &#123; suit: suits[pickedSuit], card: x % <span class="number">13</span> &#125;;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> myDeck = [&#123; suit: <span class="string">"diamonds"</span>, card: <span class="number">2</span> &#125;, &#123; suit: <span class="string">"spades"</span>, card: <span class="number">10</span> &#125;, &#123; suit: <span class="string">"hearts"</span>, card: <span class="number">4</span> &#125;];</div><div class="line"><span class="keyword">let</span> pickedCard1 = myDeck[pickCard(myDeck)];</div><div class="line">alert(<span class="string">"card: "</span> + pickedCard1.card + <span class="string">" of "</span> + pickedCard1.suit);</div><div class="line"></div><div class="line"><span class="keyword">let</span> pickedCard2 = pickCard(<span class="number">15</span>);</div><div class="line">alert(<span class="string">"card: "</span> + pickedCard2.card + <span class="string">" of "</span> + pickedCard2.suit);</div></pre></td></tr></table></figure>
<!--
Here the pickCard function will return two different things based on what the user has passed in. If the users passes in an object that represents the deck, the function will pick the card. If the user picks the card, we tell them which card they’ve picked. But how do we describe this to the type system?
-->
<p>这里的<code>pickCard</code>根据传入的参数的不同会返回不同的东西。如果用户传递一个带表桌子的对象，这个函数会返回<code>card</code>，如果用户传入的是<code>card</code>，这个函数会告诉他是哪一个。那我们如何在类型系统中描述这种情况呢？<br><!--
The answer is to supply multiple function types for the same function as a list of overloads. This list is what the compiler will use to resolve function calls. Let’s create a list of overloads that describe what our pickCard accepts and what it returns.
--><br>答案是为这个函数补充一些函数类型的重载。编译器用这些重载来解决函数调用时的问题。下面的例子演示了如何用重载来描述<code>pickCard</code>的参数和返回值。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> suits = [<span class="string">"hearts"</span>, <span class="string">"spades"</span>, <span class="string">"clubs"</span>, <span class="string">"diamonds"</span>];</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">pickCard</span>(<span class="params">x: &#123;suit: <span class="built_in">string</span>; card: <span class="built_in">number</span>; &#125;[]</span>): <span class="title">number</span></span>;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">pickCard</span>(<span class="params">x: <span class="built_in">number</span></span>): </span>&#123;suit: <span class="built_in">string</span>; card: <span class="built_in">number</span>; &#125;;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">pickCard</span>(<span class="params">x</span>): <span class="title">any</span> </span>&#123;</div><div class="line">    <span class="comment">// Check to see if we're working with an object/array</span></div><div class="line">    <span class="comment">// if so, they gave us the deck and we'll pick the card</span></div><div class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> x == <span class="string">"object"</span>) &#123;</div><div class="line">        <span class="keyword">let</span> pickedCard = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * x.length);</div><div class="line">        <span class="keyword">return</span> pickedCard;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// Otherwise just let them pick the card</span></div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> x == <span class="string">"number"</span>) &#123;</div><div class="line">        <span class="keyword">let</span> pickedSuit = <span class="built_in">Math</span>.floor(x / <span class="number">13</span>);</div><div class="line">        <span class="keyword">return</span> &#123; suit: suits[pickedSuit], card: x % <span class="number">13</span> &#125;;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> myDeck = [&#123; suit: <span class="string">"diamonds"</span>, card: <span class="number">2</span> &#125;, &#123; suit: <span class="string">"spades"</span>, card: <span class="number">10</span> &#125;, &#123; suit: <span class="string">"hearts"</span>, card: <span class="number">4</span> &#125;];</div><div class="line"><span class="keyword">let</span> pickedCard1 = myDeck[pickCard(myDeck)];</div><div class="line">alert(<span class="string">"card: "</span> + pickedCard1.card + <span class="string">" of "</span> + pickedCard1.suit);</div><div class="line"></div><div class="line"><span class="keyword">let</span> pickedCard2 = pickCard(<span class="number">15</span>);</div><div class="line">alert(<span class="string">"card: "</span> + pickedCard2.card + <span class="string">" of "</span> + pickedCard2.suit);</div></pre></td></tr></table></figure>
<!--
With this change, the overloads now give us type-checked calls to the pickCard function.
-->
<p>现在这些重载信息可用于<code>pickCard</code>调用的时候做类型检察。<br><!--
In order for the compiler to pick the correct typecheck, it follows a similar process to the underlying JavaScript. It looks at the overload list, and proceeding with the first overload attempts to call the function with the provided parameters. If it finds a match, it picks this overload as the correct overload. For this reason, its customary to order overloads from most specific to least specific.
--></p>
<!--
Note that the function pickCard(x): any piece is not part of the overload list, so it only has two overloads: one that takes an object and one that takes a number. Calling pickCard with any other parameter types would cause an error.
-->
<p>注意<code>pickCard</code>函数只有两个重载，一个是以对象为参数的另一个是以数字为参数的。以其它类型的参数来调用将得到一个编译时错误。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/10/27/class/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Qianba">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Blogs">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/10/27/class/" itemprop="url">4.类</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-10-27T00:00:00+08:00">
                2017-10-27
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/翻译/" itemprop="url" rel="index">
                    <span itemprop="name">翻译</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/翻译/编程语言/" itemprop="url" rel="index">
                    <span itemprop="name">编程语言</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/翻译/编程语言/TypeScript/" itemprop="url" rel="index">
                    <span itemprop="name">TypeScript</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>传统JavaScript使用函数后基于原型的继承来构建可复用的组件，对于习惯于面向对象的程序员来说这种复式可能有些笨拙。从ECMAScript 2015(也叫做ES6)开始,JavaScript程序员可用基于类的方式来构建面向对象的应用。在TypeScript中，开发者也可以使用这些技术。因为这些东西会被编译成跨平台的JavaScript，所以不需要等待新版的JavaScript被普遍支持。</p>
<h1 id="类"><a href="#类" class="headerlink" title="类"></a>类</h1><p>来看一个简单的基于类的例子<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Greeter &#123;</div><div class="line">    greeting: <span class="built_in">string</span>;</div><div class="line">    <span class="keyword">constructor</span>(<span class="params">message: <span class="built_in">string</span></span>) &#123;</div><div class="line">        <span class="keyword">this</span>.greeting = message;</div><div class="line">    &#125;</div><div class="line">    greet() &#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">"Hello, "</span> + <span class="keyword">this</span>.greeting;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> greeter = <span class="keyword">new</span> Greeter(<span class="string">"world"</span>);</div></pre></td></tr></table></figure></p>
<p>这种语法和C#或Java比较相似。我们声明了一个<code>Greeter</code>类，头有三个成员:一个<code>greeting</code>属性，一个构造器，一个<code>greet</code>方法。<br>在类里面，我们通过<code>this.</code>的方式来访问类的成员。<br>最后一行，我们用<code>new</code>关键字来创建了一个<code>Greeter</code>的实例。这会调用我们前面定义的构造函数，创建一个Greeter的实例并在构造函数中初始化它。</p>
<h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><p>在TypeScript中，我们可以使用通用的面向对象的模式。在基于类的编程活动中，最基本的模式便是通过继承来扩展一个已经存在的类来创建新的类。<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Animal &#123;</div><div class="line">    name: <span class="built_in">string</span>;</div><div class="line">    <span class="keyword">constructor</span>(<span class="params">theName: <span class="built_in">string</span></span>) &#123; <span class="keyword">this</span>.name = theName; &#125;</div><div class="line">    move(distanceInMeters: <span class="built_in">number</span> = <span class="number">0</span>) &#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;this.name&#125;</span> moved <span class="subst">$&#123;distanceInMeters&#125;</span>m.`</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">class</span> Snake <span class="keyword">extends</span> Animal &#123;</div><div class="line">    <span class="keyword">constructor</span>(<span class="params">name: <span class="built_in">string</span></span>) &#123; <span class="keyword">super</span>(name); &#125;</div><div class="line">    move(distanceInMeters = <span class="number">5</span>) &#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">"Slithering..."</span>);</div><div class="line">        <span class="keyword">super</span>.move(distanceInMeters);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">class</span> Horse <span class="keyword">extends</span> Animal &#123;</div><div class="line">    <span class="keyword">constructor</span>(<span class="params">name: <span class="built_in">string</span></span>) &#123; <span class="keyword">super</span>(name); &#125;</div><div class="line">    move(distanceInMeters = <span class="number">45</span>) &#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">"Galloping..."</span>);</div><div class="line">        <span class="keyword">super</span>.move(distanceInMeters);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> sam = <span class="keyword">new</span> Snake(<span class="string">"Sammy the Python"</span>);</div><div class="line"><span class="keyword">let</span> tom: Animal = <span class="keyword">new</span> Horse(<span class="string">"Tommy the Palomino"</span>);</div><div class="line"></div><div class="line">sam.move();</div><div class="line">tom.move(<span class="number">34</span>);</div></pre></td></tr></table></figure></p>
<p>这段代码里面包含了一些关于继承的特性。在这里，我们使用<code>extends</code>关键字来创建一个子类。这里你可以看见<code>Hores</code>和<code>Snake</code>继承了<code>Animal</code>类，并能访问基类中的属性。<br>包合构造函数的子类必须调用通过<code>super()</code>来基类中的构造函数。</p>
<p>这个例子一演示了如何在子类中覆盖父类中的方法。<code>Snake</code>和<code>Horse</code>中都创建了<code>move</code>方法而覆盖了基类中的方法。尽管<code>tom</code>变量被声明为了<code>Animal</code>，而实际上是<code>Horse</code>，但<code>tom.move</code>会调用到<code>Horse</code>中的方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Slithering...</div><div class="line">Sammy the Python moved 5m.</div><div class="line">Galloping...</div><div class="line">Tommy the Palomino moved 34m.</div></pre></td></tr></table></figure></p>
<h1 id="public-private-以及protected-修饰器"><a href="#public-private-以及protected-修饰器" class="headerlink" title="public,private 以及protected 修饰器"></a>public,private 以及protected 修饰器</h1><h2 id="public"><a href="#public" class="headerlink" title="public"></a>public</h2><p>public 是默认的修饰器。<br>在我们的例子中，我们可以自由的访问我们在类中定义的成员。如果你熟悉其它语言，你也许会注意到我们并没有通过<code>public</code>来说明这些成员的可访问性，比如，在C#中，需要通过public来明确的说明其可公开访问。在TypeScript中，每个成员默认是<code>public</code>的。<br>你也可以明确的指定<code>public</code>:<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Animal &#123;</div><div class="line">    <span class="keyword">public</span> name: <span class="built_in">string</span>;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">constructor</span>(<span class="params">theName: <span class="built_in">string</span></span>) &#123; <span class="keyword">this</span>.name = theName; &#125;</div><div class="line">    <span class="keyword">public</span> move(distanceInMeters: <span class="built_in">number</span>) &#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;this.name&#125;</span> moved <span class="subst">$&#123;distanceInMeters&#125;</span>m.`</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="private"><a href="#private" class="headerlink" title="private"></a>private</h2><p>理解private.<br>当一个成员被标示为<code>private</code>,将不可以在其包含它的类外面访问了。例如:<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Animal &#123;</div><div class="line">    <span class="keyword">private</span> name: <span class="built_in">string</span>;</div><div class="line">    <span class="keyword">constructor</span>(<span class="params">theName: <span class="built_in">string</span></span>) &#123; <span class="keyword">this</span>.name = theName; &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">new</span> Animal(<span class="string">"Cat"</span>).name; <span class="comment">// Error: 'name' is private;</span></div></pre></td></tr></table></figure></p>
<p>TypeScript的类型系统是结构化的类型系统。当我们比较两个不同的类型，不管它们从哪来，只要它们的成员是兼容的，我们就说这两种类型是兼容的。<br>然而，当比较的类型有<code>private</code>和<code>protected</code>的成员的时候，我们却有不同的比较方式。那么怎样的两个类型会被认为是兼容的呢?如果这两个变量中有一个变量有私有成员，那么另一个变量的私有成员必须和这个变量的私有成员在同一个地方定义(注:继承自同一个类)，那么这两个变量才有可能是兼容的。对于<code>protected</code>也是这样的。<br>让我们用一个例子来说明这点:<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Animal &#123;</div><div class="line">    <span class="keyword">private</span> name: <span class="built_in">string</span>;</div><div class="line">    <span class="keyword">constructor</span>(<span class="params">theName: <span class="built_in">string</span></span>) &#123; <span class="keyword">this</span>.name = theName; &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">class</span> Rhino <span class="keyword">extends</span> Animal &#123;</div><div class="line">    <span class="keyword">constructor</span>(<span class="params"></span>) &#123; <span class="keyword">super</span>(<span class="string">"Rhino"</span>); &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">class</span> Employee &#123;</div><div class="line">    <span class="keyword">private</span> name: <span class="built_in">string</span>;</div><div class="line">    <span class="keyword">constructor</span>(<span class="params">theName: <span class="built_in">string</span></span>) &#123; <span class="keyword">this</span>.name = theName; &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> animal = <span class="keyword">new</span> Animal(<span class="string">"Goat"</span>);</div><div class="line"><span class="keyword">let</span> rhino = <span class="keyword">new</span> Rhino();</div><div class="line"><span class="keyword">let</span> employee = <span class="keyword">new</span> Employee(<span class="string">"Bob"</span>);</div><div class="line"></div><div class="line">animal = rhino;</div><div class="line">animal = employee; <span class="comment">// Error: 'Animal' and 'Employee' are not compatible</span></div></pre></td></tr></table></figure></p>
<p>在这个例子中，我们有一个<code>Animal</code>类和其子类<code>Rhino</code>类，以及一个看起来很向<code>Animal</code>的<code>Employee</code>类(注:回想鸭类型)。我们创建这些类的实例并试着用它们相互赋值，看会发生什么。因为<code>Animal</code>和<code>Rhino</code>的private成员有相同的”出处”，所以它们是兼容的。然而<code>Employee</code>却不是这么回事了。当我们式着将<code>Employee</code>类型的变量赋值给<code>Animal</code>类型的变量的时候，我们会得到一个类型不兼容的错误提示。尽管<code>Employee</code>也有一个叫<code>name</code>的私有变量，但该变量却不是在Animal中定义的那个。</p>
<h2 id="理解protected"><a href="#理解protected" class="headerlink" title="理解protected"></a>理解protected</h2><p><code>protected</code>和<code>private</code>是类似的，不过呢，protected修饰的成员在起子类中也是可以访问的。<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Person &#123;</div><div class="line">    <span class="keyword">protected</span> name: <span class="built_in">string</span>;</div><div class="line">    <span class="keyword">constructor</span>(<span class="params">name: <span class="built_in">string</span></span>) &#123; <span class="keyword">this</span>.name = name; &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">class</span> Employee <span class="keyword">extends</span> Person &#123;</div><div class="line">    <span class="keyword">private</span> department: <span class="built_in">string</span>;</div><div class="line"></div><div class="line">    <span class="keyword">constructor</span>(<span class="params">name: <span class="built_in">string</span>, department: <span class="built_in">string</span></span>) &#123;</div><div class="line">        <span class="keyword">super</span>(name);</div><div class="line">        <span class="keyword">this</span>.department = department;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> getElevatorPitch() &#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">`Hello, my name is <span class="subst">$&#123;this.name&#125;</span> and I work in <span class="subst">$&#123;this.department&#125;</span>.`</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> howard = <span class="keyword">new</span> Employee(<span class="string">"Howard"</span>, <span class="string">"Sales"</span>);</div><div class="line"><span class="built_in">console</span>.log(howard.getElevatorPitch());</div><div class="line"><span class="built_in">console</span>.log(howard.name); <span class="comment">// error</span></div></pre></td></tr></table></figure></p>
<p>我们不能在<code>Person</code>类外面访问<code>name</code>属性，但我们可以在<code>Employee</code>类的方法中访问它，因为Employee继承于<code>Person</code>.<br>构造器也可用protected修饰，这表明这个类不能从外部实例化，但是可被继承。例如:<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Person &#123;</div><div class="line">    <span class="keyword">protected</span> name: <span class="built_in">string</span>;</div><div class="line">    <span class="keyword">protected</span> <span class="keyword">constructor</span>(<span class="params">theName: <span class="built_in">string</span></span>) &#123; <span class="keyword">this</span>.name = theName; &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// Employee can extend Person</span></div><div class="line"><span class="keyword">class</span> Employee <span class="keyword">extends</span> Person &#123;</div><div class="line">    <span class="keyword">private</span> department: <span class="built_in">string</span>;</div><div class="line"></div><div class="line">    <span class="keyword">constructor</span>(<span class="params">name: <span class="built_in">string</span>, department: <span class="built_in">string</span></span>) &#123;</div><div class="line">        <span class="keyword">super</span>(name);</div><div class="line">        <span class="keyword">this</span>.department = department;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> getElevatorPitch() &#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">`Hello, my name is <span class="subst">$&#123;this.name&#125;</span> and I work in <span class="subst">$&#123;this.department&#125;</span>.`</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> howard = <span class="keyword">new</span> Employee(<span class="string">"Howard"</span>, <span class="string">"Sales"</span>);</div><div class="line"><span class="keyword">let</span> john = <span class="keyword">new</span> Person(<span class="string">"John"</span>); <span class="comment">// Error: The 'Person' constructor is protected</span></div></pre></td></tr></table></figure></p>
<h2 id="Readonly-修饰符"><a href="#Readonly-修饰符" class="headerlink" title="Readonly 修饰符"></a>Readonly 修饰符</h2><p>你也可以使用<code>readonly</code>关键字来表示一个属性是只读的。只读属性只能在其声明的地方或构造器中被初始化。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">class Octopus &#123;</div><div class="line">    readonly name: string;</div><div class="line">    readonly numberOfLegs: number = 8;</div><div class="line">    constructor (theName: string) &#123;</div><div class="line">        this.name = theName;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">let dad = new Octopus(&quot;Man with the 8 strong legs&quot;);</div><div class="line">dad.name = &quot;Man with the 3-piece suit&quot;; // error! name is readonly.</div></pre></td></tr></table></figure></p>
<h2 id="参数属性"><a href="#参数属性" class="headerlink" title="参数属性"></a>参数属性</h2><p>在上一个例子中，在Octopus类中，我们声明了只读属性<code>name</code> 并在Octopus类的构造函数中初始化了这个属性。<br>这其实是一种常见的模式，<code>参数属性</code>可以简化这个过程，让你在同一个地方创建并初始化一个成员。<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Octopus &#123;</div><div class="line">    readonly numberOfLegs: <span class="built_in">number</span> = <span class="number">8</span>;</div><div class="line">    <span class="keyword">constructor</span>(<span class="params">readonly name: <span class="built_in">string</span></span>) &#123;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>注意我们使用<code>readonly name:string</code>来声明了一个参数，这会在类上创建并初始化一个<code>name</code>成员。这样我们就把成员的声明和赋值放在了同一个地方。<br><code>属性参数</code>用一个前缀来声明，这个前缀可以是访问修饰符或者<code>readonly</code> 或这同时有这两者。使用<code>private</code>来声明参数属性将得到一个私有的属性，同样public,protected 声明的参数属性将得到公开或受保护的属性。</p>
<h1 id="访问器"><a href="#访问器" class="headerlink" title="访问器"></a>访问器</h1><p>TypeScript支持<code>getter</code>和<code>setter</code>来拦截对对象成员的访问。这让你可以更好的控制对象成员是如何被访问的。<br>让我们把一个简单的类转化成使用<code>get</code>和<code>set</code>的类。让我们从一个没有<code>getter</code>和<code>setter</code>的类开始<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Employee &#123;</div><div class="line">fullName:strin</div><div class="line">&#125;</div><div class="line"><span class="keyword">let</span> employee = <span class="keyword">new</span> Employee();</div><div class="line">employee.fullName = <span class="string">"Bob Smith"</span>;</div><div class="line"><span class="keyword">if</span> (employee.fullName) &#123;</div><div class="line">    <span class="built_in">console</span>.log(employee.fullName);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>尽管让<code>fullName</code>可被直接访问会带来便利，但当人们可以突发奇想的修改类成员也会带来一些麻烦。<br>在下面的版本中，我们在修改fullName之前做一些检察以确保修改者有正确的修改密码。我们的做法是将对<code>fullName</code>的直接访问替换为用一个<code>set</code>函数来做。也相对应的添加一个<code>get</code>函数来使<code>fullName</code>可被获取<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> passcode = <span class="string">"secret passcode"</span>;</div><div class="line"></div><div class="line"><span class="keyword">class</span> Employee &#123;</div><div class="line">    <span class="keyword">private</span> _fullName: <span class="built_in">string</span>;</div><div class="line"></div><div class="line">    <span class="keyword">get</span> fullName(): <span class="built_in">string</span> &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>._fullName;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">set</span> fullName(newName: <span class="built_in">string</span>) &#123;</div><div class="line">        <span class="keyword">if</span> (passcode &amp;&amp; passcode == <span class="string">"secret passcode"</span>) &#123;</div><div class="line">            <span class="keyword">this</span>._fullName = newName;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">            <span class="built_in">console</span>.log(<span class="string">"Error: Unauthorized update of employee!"</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> employee = <span class="keyword">new</span> Employee();</div><div class="line">employee.fullName = <span class="string">"Bob Smith"</span>;</div><div class="line"><span class="keyword">if</span> (employee.fullName) &#123;</div><div class="line">    <span class="built_in">console</span>.log(employee.fullName);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<blockquote>
<p>关于访问器的说明<br>首先，使用访问器你需要把编译的输出目标设置为ES5或之后版。降级为ES3是不被支持的。<br>其次，只有<code>get</code>没有<code>set</code>的访问器会被推断为<code>readonly</code>.在产生<code>.d.ts</code>文件时这很有用，因为使用该属性的人可以知道这是一个只读的属性。</p>
</blockquote>
<h1 id="静态属性"><a href="#静态属性" class="headerlink" title="静态属性"></a>静态属性</h1><!--Up to this point-->
<p>到目前为止,我们只讨论了实例的成员(注:后半句多余，没译)。我们也可以创建类的静态成员——既那些在类上可访问的成员。在下面的例子中，我们在<code>origin</code>上使用<code>static</code>关键字，使其作为所有<code>网格</code>的值。所有实例通过<code>类名.</code>的方式来访问类成员。和<code>this.</code>类似，我们用<code>Grid.</code>来访问静态成员。<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Grid &#123;</div><div class="line">    <span class="keyword">static</span> origin = &#123;x: <span class="number">0</span>, y: <span class="number">0</span>&#125;;</div><div class="line">    calculateDistanceFromOrigin(point: &#123;x: <span class="built_in">number</span>; y: <span class="built_in">number</span>;&#125;) &#123;</div><div class="line">        <span class="keyword">let</span> xDist = (point.x - Grid.origin.x);</div><div class="line">        <span class="keyword">let</span> yDist = (point.y - Grid.origin.y);</div><div class="line">        <span class="keyword">return</span> <span class="built_in">Math</span>.sqrt(xDist * xDist + yDist * yDist) / <span class="keyword">this</span>.scale;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">constructor</span> (<span class="params"><span class="keyword">public</span> scale: <span class="built_in">number</span></span>) &#123; &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> grid1 = <span class="keyword">new</span> Grid(<span class="number">1.0</span>);  <span class="comment">// 1x scale</span></div><div class="line"><span class="keyword">let</span> grid2 = <span class="keyword">new</span> Grid(<span class="number">5.0</span>);  <span class="comment">// 5x scale</span></div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(grid1.calculateDistanceFromOrigin(&#123;x: <span class="number">10</span>, y: <span class="number">10</span>&#125;));</div><div class="line"><span class="built_in">console</span>.log(grid2.calculateDistanceFromOrigin(&#123;x: <span class="number">10</span>, y: <span class="number">10</span>&#125;));</div><div class="line">Abstract Classes</div></pre></td></tr></table></figure></p>
<h1 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h1><p>抽象类常做基类，他们不能直接被实例化。可接口不同的是，抽象类可包括其成员的一些实现。使用<code>abstract</code>关键字来定义抽象类和抽象方法。<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> Animal &#123;</div><div class="line">    <span class="keyword">abstract</span> makeSound(): <span class="built_in">void</span>;</div><div class="line">    move(): <span class="built_in">void</span> &#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">"roaming the earth..."</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>抽象类中的抽象方法必须在在类中被实现(注:除非子类也是抽象类)。抽象方法的语法和接口方法的语法是类似的，都是只有方法的签名而没有方法体。不同的是，抽象方法必须用<code>abstract</code>来修饰还可以加访问修饰符。<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> Department &#123;</div><div class="line"></div><div class="line">    <span class="keyword">constructor</span>(<span class="params"><span class="keyword">public</span> name: <span class="built_in">string</span></span>) &#123;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    printName(): <span class="built_in">void</span> &#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">"Department name: "</span> + <span class="keyword">this</span>.name);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">abstract</span> printMeeting(): <span class="built_in">void</span>; <span class="comment">// must be implemented in derived classes</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">class</span> AccountingDepartment <span class="keyword">extends</span> Department &#123;</div><div class="line"></div><div class="line">    <span class="keyword">constructor</span>(<span class="params"></span>) &#123;</div><div class="line">        <span class="keyword">super</span>(<span class="string">"Accounting and Auditing"</span>); <span class="comment">// constructors in derived classes must call super()</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    printMeeting(): <span class="built_in">void</span> &#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">"The Accounting Department meets each Monday at 10am."</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    generateReports(): <span class="built_in">void</span> &#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">"Generating accounting reports..."</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> department: Department; <span class="comment">// ok to create a reference to an abstract type</span></div><div class="line">department = <span class="keyword">new</span> Department(); <span class="comment">// error: cannot create an instance of an abstract class</span></div><div class="line">department = <span class="keyword">new</span> AccountingDepartment(); <span class="comment">// ok to create and assign a non-abstract subclass</span></div><div class="line">department.printName();</div><div class="line">department.printMeeting();</div><div class="line">department.generateReports(); <span class="comment">// error: method doesn't exist on declared abstract type</span></div></pre></td></tr></table></figure></p>
<h1 id="高级技术"><a href="#高级技术" class="headerlink" title="高级技术"></a>高级技术</h1><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><p>当你在TypeScript中声明了一个类，你实际上同时声明了很多东西。首先是类:<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Greeter &#123;</div><div class="line">    greeting: <span class="built_in">string</span>;</div><div class="line">    <span class="keyword">constructor</span>(<span class="params">message: <span class="built_in">string</span></span>) &#123;</div><div class="line">        <span class="keyword">this</span>.greeting = message;</div><div class="line">    &#125;</div><div class="line">    greet() &#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">"Hello, "</span> + <span class="keyword">this</span>.greeting;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> greeter: Greeter;</div><div class="line">greeter = <span class="keyword">new</span> Greeter(<span class="string">"world"</span>);</div><div class="line"><span class="built_in">console</span>.log(greeter.greet());</div></pre></td></tr></table></figure></p>
<p>当我们指定<code>let greeter:Greeter</code>，我们使用<code>Greeter</code>作为<code>Greeter</code>类的实例的类型，面向对象语言的程序员对此很熟悉。<br>我们也创建了一个叫做<code>构造函数</code>的东西。当我们new一个类的时候，这个函数就会被调用。为了看看实际上是什么样子，让我们看看上面的代码编译出来的<code>JavaScript</code><br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> Greeter = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Greeter</span>(<span class="params">message</span>) </span>&#123;</div><div class="line">        <span class="keyword">this</span>.greeting = message;</div><div class="line">    &#125;</div><div class="line">    Greeter.prototype.greet = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">"Hello, "</span> + <span class="keyword">this</span>.greeting;</div><div class="line">    &#125;;</div><div class="line">    <span class="keyword">return</span> Greeter;</div><div class="line">&#125;)();</div><div class="line"></div><div class="line"><span class="keyword">let</span> greeter;</div><div class="line">greeter = <span class="keyword">new</span> Greeter(<span class="string">"world"</span>);</div><div class="line"><span class="built_in">console</span>.log(greeter.greet());</div></pre></td></tr></table></figure></p>
<p>构造函数被分配给了<code>Greeter</code>变量，都我们new Greeter的时候，就会调用这个构造函数并得到一个实例。构造函数上也包含了类的静态成员。另一个思考类的方式是其可分为<code>实例侧</code>和<code>静态侧</code><br>修改一下前面的例子来演示其中的不同<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Greeter &#123;</div><div class="line">    <span class="keyword">static</span> standardGreeting = <span class="string">"Hello, there"</span>;</div><div class="line">    greeting: <span class="built_in">string</span>;</div><div class="line">    greet() &#123;</div><div class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.greeting) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="string">"Hello, "</span> + <span class="keyword">this</span>.greeting;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">return</span> Greeter.standardGreeting;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> greeter1: Greeter;</div><div class="line">greeter1 = <span class="keyword">new</span> Greeter();</div><div class="line"><span class="built_in">console</span>.log(greeter1.greet());</div><div class="line"></div><div class="line"><span class="keyword">let</span> greeterMaker: <span class="keyword">typeof</span> Greeter = Greeter;</div><div class="line">greeterMaker.standardGreeting = <span class="string">"Hey there!"</span>;</div><div class="line"></div><div class="line"><span class="keyword">let</span> greeter2: Greeter = <span class="keyword">new</span> greeterMaker();</div><div class="line"><span class="built_in">console</span>.log(greeter2.greet());</div></pre></td></tr></table></figure></p>
<p>在这个例子中，<code>greeter1</code>和前面的类似，我们使用<code>Greeter</code>类来创建它，并使用使用创建后的对象。<br>接下来，我们直接使用类。我们创建了一个<code>greeterMaker</code>变量，这个变量引用了类本身，或者说它是类的构造函数。这的<code>typeof Greeter</code>意思是:给我Greeter类自身的类型而不是它的一个实例。或者，更准确的说:给我那个叫Greeter的符号的类型。这个类型将包含Greeter的所有静态成员以及创建Greeter实例的构造函数。现在我们可以在greeterMaker上使用new关键字来创建Greeter的实例。</p>
<h2 id="类用作接口"><a href="#类用作接口" class="headerlink" title="类用作接口"></a>类用作接口</h2><p>正如前一节所说，一个类声明创建了两个东西:一个类型和一个构造函数。因为类创建了类型，所以你可以把类用在某些能用接口的地方。<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Point &#123;</div><div class="line">    x: <span class="built_in">number</span>;</div><div class="line">    y: <span class="built_in">number</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">interface</span> Point3d <span class="keyword">extends</span> Point &#123;</div><div class="line">    z: <span class="built_in">number</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> point3d: Point3d = &#123;x: <span class="number">1</span>, y: <span class="number">2</span>, z: <span class="number">3</span>&#125;;</div></pre></td></tr></table></figure></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/10/26/interface/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Qianba">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Blogs">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/10/26/interface/" itemprop="url">3.接口</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-10-26T22:30:02+08:00">
                2017-10-26
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/翻译/" itemprop="url" rel="index">
                    <span itemprop="name">翻译</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/翻译/编程语言/" itemprop="url" rel="index">
                    <span itemprop="name">编程语言</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/翻译/编程语言/TypeScript/" itemprop="url" rel="index">
                    <span itemprop="name">TypeScript</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p>TypeScript的核心概念之一就是类型检查，Typescript的类型检查是基于值的“形状”而言的，这种类型被称为“鸭类型”或“结构化类型”（注：如果一种生物走起路来像鸭子，叫起来像鸭子，就认为它是鸭子）。在TypeScript中，是给类型“命名”的一种角色，也是种约束你的代码的有效方式。</p>
<h1 id="第一个接口"><a href="#第一个接口" class="headerlink" title="第一个接口"></a>第一个接口</h1><p>关于接口最简单的说明，如下例：<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">printLabel</span>(<span class="params">labelledObj: &#123; label: <span class="built_in">string</span> &#125;</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(labelledObj.label);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> myObj = &#123;size: <span class="number">10</span>, label: <span class="string">"Size 10 Object"</span>&#125;;</div><div class="line">printLabel(myObj);</div></pre></td></tr></table></figure></p>
<p>类型检查器检查对<code>printLabel</code>的调用，该函数需要一个参数，这个参数是一个有串类型的<code>label</code>属性的对象。调用时传递给该函数的参数实际上除了<code>label</code>属性，还有些其它属性。编译器只会确保有有相匹配的那些属性，但也有一些情况不是这样简单的处理。<br>我们可以改写这个例子，这次我们使用一个接口来描述<code>printLabel</code>的参数。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">interface</span> LabelledValue &#123;</div><div class="line">    label: <span class="built_in">string</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">printLabel</span>(<span class="params">labelledObj: LabelledValue</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(labelledObj.label);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> myObj = &#123;size: <span class="number">10</span>, label: <span class="string">"Size 10 Object"</span>&#125;;</div><div class="line">printLabel(myObj);</div></pre></td></tr></table></figure>
<p>现在我们可用<code>LabelledValue</code>这个接口来描述<code>printLabel</code>的参数。我们并没有明确的让传递给<code>printLabel</code>的参数要实现<code>LabelledValue</code>这个接口，在其它语言中可能需要这样做。这里只在乎的是“形状”。如果我们传递过去的东西和<code>LabelledValue</code>是兼容的就可以的。</p>
<p>值得说明的是，类型检察器不在意属性出现的顺序，只在有意识必要的那些属性以及这些属性的类型是正确的。</p>
<h1 id="可选属性"><a href="#可选属性" class="headerlink" title="可选属性"></a>可选属性</h1><p>接口中并不是每个属性都是必须的，有的属性在某些情况下才会出现，甚至不会出现。在使用所谓的“option bags”（注:即把所有的选项放在一个对象里面）的模式的时候可选属性是很常用的。<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">interface</span> SquareConfig &#123;</div><div class="line">    color?: <span class="built_in">string</span>;</div><div class="line">    width?: <span class="built_in">number</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">createSquare</span>(<span class="params">config: SquareConfig</span>): </span>&#123;color: <span class="built_in">string</span>; area: <span class="built_in">number</span>&#125; &#123;</div><div class="line">    <span class="keyword">let</span> newSquare = &#123;color: <span class="string">"white"</span>, area: <span class="number">100</span>&#125;;</div><div class="line">    <span class="keyword">if</span> (config.color) &#123;</div><div class="line">        newSquare.color = config.color;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (config.width) &#123;</div><div class="line">        newSquare.area = config.width * config.width;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> newSquare;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> mySquare = createSquare(&#123;color: <span class="string">"black"</span>&#125;);</div></pre></td></tr></table></figure></p>
<p>有可选属性的接口的语法和普通接口是类似的，只是每个可选属性的名字后面用一个<code>?</code>标记出来。</p>
<p>可选属性的优势是你可以描述那些可能出现的属性而且避免那些没有在接口中声明的属性(注:可防止拼写错误)。比如，我们把<code>color</code>错写成了<code>clor</code>，TypeScript将给出一个错误消息。<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">interface</span> SquareConfig &#123;</div><div class="line">    color?: <span class="built_in">string</span>;</div><div class="line">    width?: <span class="built_in">number</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">createSquare</span>(<span class="params">config: SquareConfig</span>): </span>&#123; color: <span class="built_in">string</span>; area: <span class="built_in">number</span> &#125; &#123;</div><div class="line">    <span class="keyword">let</span> newSquare = &#123;color: <span class="string">"white"</span>, area: <span class="number">100</span>&#125;;</div><div class="line">    <span class="keyword">if</span> (config.color) &#123;</div><div class="line">        <span class="comment">// Error: Property 'clor' does not exist on type 'SquareConfig'</span></div><div class="line">        newSquare.color = config.clor;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (config.width) &#123;</div><div class="line">        newSquare.area = config.width * config.width;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> newSquare;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> mySquare = createSquare(&#123;color: <span class="string">"black"</span>&#125;);</div></pre></td></tr></table></figure></p>
<h1 id="只读属性"><a href="#只读属性" class="headerlink" title="只读属性"></a>只读属性</h1><p>一些属性只应该在一个对象创建的时候被修改，你可以通过在属性名前加一个<code>readonly</code>关键字来说明这点。<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">interface</span> Point &#123;</div><div class="line">    readonly x: <span class="built_in">number</span>;</div><div class="line">    readonly y: <span class="built_in">number</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>你可以通过对象字面量的方式来创建<code>Point</code>对象，一旦创建对象后，就不再能修改<code>x</code>和<code>y</code>的值了。<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> p1: Point = &#123; x: <span class="number">10</span>, y: <span class="number">20</span> &#125;;</div><div class="line">p1.x = <span class="number">5</span>; <span class="comment">// error!</span></div></pre></td></tr></table></figure></p>
<p>TypeScript有一个<code>ReadonlyArray&lt;T&gt;</code>类型，基本和<code>Array&lt;T&gt;</code>一样，只不过那些修改类的方法被移除了，所以你可以确保数组在被创建之后就不再被修改了。<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> a: <span class="built_in">number</span>[] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</div><div class="line"><span class="keyword">let</span> ro: ReadonlyArray&lt;<span class="built_in">number</span>&gt; = a;</div><div class="line">ro[<span class="number">0</span>] = <span class="number">12</span>; <span class="comment">// error!</span></div><div class="line">ro.push(<span class="number">5</span>); <span class="comment">// error!</span></div><div class="line">ro.length = <span class="number">100</span>; <span class="comment">// error!</span></div><div class="line">a = ro; <span class="comment">// error!</span></div></pre></td></tr></table></figure></p>
<p>这段代码的最后一行表明，你不可以把一个ReadOnlyArray赋值给一个Array变量。<br>除非你使用类型断言:<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">a=ro <span class="keyword">as</span> <span class="built_in">number</span>[]</div></pre></td></tr></table></figure></p>
<p><strong>readonly</strong> vs <strong>const</strong><br>区别使用<code>readonly</code>还是<code>const</code>的最简单的方式是看是在属性上还是在变量上。前者使用<code>readonly</code>后者使用<code>const</code></p>
<h1 id="多余属性检查"><a href="#多余属性检查" class="headerlink" title="多余属性检查"></a>多余属性检查</h1><p>在我们的第一个例子中，我们把<code>{ size: number; label: string; }</code>传递给接受<code>{ label: string; }</code>的函数。我们也了解了可选属性，以及其在”option bags”时候的用处。<br>然而，这两者简单的合起来用却会遇到和JavaScript中一样的麻烦。例如:<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">interface</span> SquareConfig &#123;</div><div class="line">    color?: <span class="built_in">string</span>;</div><div class="line">    width?: <span class="built_in">number</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">createSquare</span>(<span class="params">config: SquareConfig</span>): </span>&#123; color: <span class="built_in">string</span>; area: <span class="built_in">number</span> &#125; &#123;</div><div class="line">    <span class="comment">// ...</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> mySquare = createSquare(&#123; colour: <span class="string">"red"</span>, width: <span class="number">100</span> &#125;);</div></pre></td></tr></table></figure></p>
<p>注意这里在调用<code>createSquare</code>时候传递的参数中用的是<code>colour</code>而非<code>color</code>.在JavaScript中，这种错误会静悄悄的发生。你会觉得你的程序是对的:<code>width</code>的类型是兼容的，没有<code>color</code>属性，多出一个<code>colour</code>属性。<br>然而，TypeScript的立场是这也许会是程序中的一个bug。<strong>*当一个对象被赋值 给其它变量，或通过参数传递的时候，对象会被特殊对待，经过所谓的”<code>多余属性检查</code>“</strong>。如果该对象含有目标类型所没有的属性，就会报错:<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// error: 'colour' not expected in type 'SquareConfig'</span></div><div class="line"><span class="keyword">let</span> mySquare = createSquare(&#123; colour: <span class="string">"red"</span>, width: <span class="number">100</span> &#125;);</div></pre></td></tr></table></figure></p>
<p>要通过这种检查也是十分简单的，使用类型断言就可以了:<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> mySquare = createSquare(&#123; width: <span class="number">100</span>, opacity: <span class="number">0.5</span> &#125; <span class="keyword">as</span> SquareConfig);</div></pre></td></tr></table></figure></p>
<p>但是，一个更好的方法是添加字符串索引签名(string index signature),当然，是在如果你确定被传递的对象是可有一些额外的属性的情况下。如果<code>SquareConfig</code>可有其它的属性，你可以这样定义它:<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">interface</span> SquareConfig &#123;</div><div class="line">    color?: <span class="built_in">string</span>;</div><div class="line">    width?: <span class="built_in">number</span>;</div><div class="line">    [propName: <span class="built_in">string</span>]: <span class="built_in">any</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>简单讨论一下索引签名。我们说<code>SquareConfig</code>可有任何数量的属性。只有这些属性的名字不是<code>color</code>和<code>width</code>，其类型是any。<br>还有一种通过检察的方式——这种放式可能会让人惊讶——把对象赋值给另外一个变量:<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> squareOptions = &#123; colour: <span class="string">"red"</span>, width: <span class="number">100</span> &#125;;</div><div class="line"><span class="keyword">let</span> mySquare = createSquare(squareOptions);</div></pre></td></tr></table></figure></p>
<p>因为<code>squareOptions</code>不会经历<code>多余属性检查</code>，那么也就不会有编译错误了。</p>
<p>记住，对于这段简单代码，你也许会认为不会通过检察。对于更复杂的对象字面量，它们有一些方法和状态变量，所以直接传递一个对象而非对象字面量的时候,TypeScript不会对其进行<code>多余属性检察</code>。而以对象字面量为<code>option bags</code>这样的参数的时候，<code>多余属性检察</code>的确可以必免很多bug.这也意味着，如果你在用<code>option bags</code>时遇到了<code>多余属性检察</code>报的错误，你也许就需要修改你的类型定义。例如，对于上面的例子，如果拥有<code>color</code>和<code>colour</code>属性的对象都可以作为<code>createSquare</code>的参数，那么你就需要修改<code>SquareConfig</code>的定义了。</p>
<h1 id="函数类型"><a href="#函数类型" class="headerlink" title="函数类型"></a>函数类型</h1><p>TypeScript中的<code>接口</code>这一概念可广泛的用来描述JavaScript中的东西。除了用来描述对象及其属性，接口也能用来描述函数的类型。</p>
<p>为了用接口来描述函数，我们给这些接口一个<code>调用签名</code>。这类似于函数的声明，参数表中的每个参数都要有类型和名字。<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">interface</span> SearchFunc &#123;</div><div class="line">    (source: <span class="built_in">string</span>, subString: <span class="built_in">string</span>): <span class="built_in">boolean</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>一旦定义了这样的接口，我们就可以像使用普通接口一样的使用它。<br>下面的例子演示了如何用函数接口来定义一个变量并为其赋值。<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> mySearch: SearchFunc;</div><div class="line">mySearch = <span class="function"><span class="keyword">function</span>(<span class="params">source: <span class="built_in">string</span>, subString: <span class="built_in">string</span></span>) </span>&#123;</div><div class="line">    <span class="keyword">let</span> result = source.search(subString);</div><div class="line">    <span class="keyword">return</span> result &gt; <span class="number">-1</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>对函数类型的类型检察不要求参数的名字相匹配:<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> mySearch: SearchFunc;</div><div class="line">mySearch = <span class="function"><span class="keyword">function</span>(<span class="params">src: <span class="built_in">string</span>, sub: <span class="built_in">string</span></span>): <span class="title">boolean</span> </span>&#123;</div><div class="line">    <span class="keyword">let</span> result = src.search(sub);</div><div class="line">    <span class="keyword">return</span> result &gt; <span class="number">-1</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如果将函数赋值给指明类型的变量，例如<code>SearchFunc</code>，而你没有指定参数的类型，TypeScript的<code>上下文类型</code>系统能够推断出参数的类型。<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> mySearch: SearchFunc;</div><div class="line">mySearch = <span class="function"><span class="keyword">function</span>(<span class="params">src, sub</span>) </span>&#123;</div><div class="line">    <span class="keyword">let</span> result = src.search(sub);</div><div class="line">    <span class="keyword">return</span> result &gt; <span class="number">-1</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里函数的返回值暗示了其类型(<code>false</code>或<code>true</code>).如果这里的返回值不是布尔类型的，TypeScript将会给出一个类型不匹配的警告。</p>
<h1 id="可索引的类型"><a href="#可索引的类型" class="headerlink" title="可索引的类型"></a>可索引的类型</h1><p>除了可用接口来描述函数，我们有可用接口来描述<code>索引</code>，类似于<code>a[10]</code>或<code>ageMap[&quot;daniel&quot;]。可索引的类型有一个</code>索引签名<code>，其用于描述我们如何来索引对象中的值，以及说明</code>索引`和返回值的类型。<br>例如:<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">interface</span> StringArray &#123;</div><div class="line">    [index: <span class="built_in">number</span>]: <span class="built_in">string</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> myArray: StringArray;</div><div class="line">myArray = [<span class="string">"Bob"</span>, <span class="string">"Fred"</span>];</div><div class="line"></div><div class="line"><span class="keyword">let</span> myStr: <span class="built_in">string</span> = myArray[<span class="number">0</span>];</div></pre></td></tr></table></figure></p>
<p>这里，我们定义了一个有索引签名的<code>StringArray</code>接口。这个索引签名说明<code>StringArray</code>可用数字来作索引并返回一个<code>string</code>类型的值。</p>
<p>可用作索引的类型有<code>string</code>和<code>number</code>两种。可在同一个接口中使用这两种索引，但是数字索引的返回值类型必须是串索引的<strong>子类型</strong>。这是因为当我们用数字作为索引，JavaScript会把它转换为字符串。即用<code>100</code>作索引实际上和用<code>&quot;100&quot;</code>作索引是同一回事，所以我们需要这两种类型一致。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Animal &#123;</div><div class="line">    name: <span class="built_in">string</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">class</span> Dog <span class="keyword">extends</span> Animal &#123;</div><div class="line">    breed: <span class="built_in">string</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// Error: indexing with a 'string' will sometimes get you an Animal!</span></div><div class="line"><span class="keyword">interface</span> NotOkay &#123;</div><div class="line">    [x: <span class="built_in">number</span>]: Animal;</div><div class="line">    [x: <span class="built_in">string</span>]: Dog;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>注：徦设TypeScript中没有这个限制，那么就会有下面演示的问题</p>
</blockquote>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> notOkey:NotOkay = &#123;&#125;</div><div class="line">notOkey[<span class="number">10</span>]=<span class="keyword">new</span> Animal()</div><div class="line"><span class="comment">//TypeScript 认为notOkey["10"]为Dog，那么就会有潜在的问题</span></div><div class="line">notOkey[<span class="string">"10"</span>]</div></pre></td></tr></table></figure>
<p>尽管串索引是一个强有力的描述<code>字典模式</code>的方式，但它也强制约束了所有属性的类型。这是因为<code>obj.prop</code>和<code>obj[&quot;prop&quot;]</code>是等价的。下面的例子中<code>name</code>和串索引的类型不一致，类型检察器将会给出一个错误。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">interface</span> NumberDictionary &#123;</div><div class="line">    [index: <span class="built_in">string</span>]: <span class="built_in">number</span>;</div><div class="line">    length: <span class="built_in">number</span>;    <span class="comment">// ok, length is a number</span></div><div class="line">    name: <span class="built_in">string</span>;      <span class="comment">// error, the type of 'name' is not a subtype of the indexer</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>最后，你可以让索引是只读的:<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">interface</span> ReadonlyStringArray &#123;</div><div class="line">    readonly [index: <span class="built_in">number</span>]: <span class="built_in">string</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">let</span> myArray: ReadonlyStringArray = [<span class="string">"Alice"</span>, <span class="string">"Bob"</span>];</div><div class="line">myArray[<span class="number">2</span>] = <span class="string">"Mallory"</span>; <span class="comment">// error!</span></div></pre></td></tr></table></figure></p>
<h1 id="类类型"><a href="#类类型" class="headerlink" title="类类型"></a>类类型</h1><h2 id="实现一个接口"><a href="#实现一个接口" class="headerlink" title="实现一个接口"></a>实现一个接口</h2><p>在像C#和Java之类的语言中，接口的一个典型的用法是用来强制类要实现一些方法，TypeScript也可这样用。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">interface</span> ClockInterface &#123;</div><div class="line">    currentTime: <span class="built_in">Date</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">class</span> Clock <span class="keyword">implements</span> ClockInterface &#123;</div><div class="line">    currentTime: <span class="built_in">Date</span>;</div><div class="line">    <span class="keyword">constructor</span>(<span class="params">h: <span class="built_in">number</span>, m: <span class="built_in">number</span></span>) &#123; &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>你也可以在接口中指定成员方法，在类中实现这些方法。<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">interface</span> ClockInterface &#123;</div><div class="line">    currentTime: <span class="built_in">Date</span>;</div><div class="line">    setTime(d: <span class="built_in">Date</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">class</span> Clock <span class="keyword">implements</span> ClockInterface &#123;</div><div class="line">    currentTime: <span class="built_in">Date</span>;</div><div class="line">    setTime(d: <span class="built_in">Date</span>) &#123;</div><div class="line">        <span class="keyword">this</span>.currentTime = d;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">constructor</span>(<span class="params">h: <span class="built_in">number</span>, m: <span class="built_in">number</span></span>) &#123; &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>接口用来描述类的公开部分。</p>
<blockquote>
<p>This prohibits you from using them to check that a class also has particular types for the private side of the class instance.(每个单词都认识，就是不知道它在说什么)</p>
</blockquote>
<h2 id="静态侧类型和实例侧类型的不同之处"><a href="#静态侧类型和实例侧类型的不同之处" class="headerlink" title="静态侧类型和实例侧类型的不同之处"></a>静态侧类型和实例侧类型的不同之处</h2><!--
When working with classes and interfaces, it helps to keep in mind that a class has two types: the type of the static side and the type of the instance side. You may notice that if you create an interface with a construct signature and try to create a class that implements this interface you get an error:
-->
<p>当使用接口和类的时候，需注意的是一个类有两个类型：静态侧类型(type of static side)和实例侧类型（type of instance side）。如果你创建了一个拥有构造函数的签名的接口，并试图用一个类来实现这个接口，那你会得到一个错误：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">interface</span> ClockConstructor &#123;</div><div class="line">    <span class="keyword">new</span> (hour: <span class="built_in">number</span>, minute: <span class="built_in">number</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">class</span> Clock <span class="keyword">implements</span> ClockConstructor &#123;</div><div class="line">    currentTime: <span class="built_in">Date</span>;</div><div class="line">    <span class="keyword">constructor</span>(<span class="params">h: <span class="built_in">number</span>, m: <span class="built_in">number</span></span>) &#123; &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<!--
This is because when a class implements an interface, only the instance side of the class is checked. Since the constructor sits in the static side, it is not included in this check.


Instead, you would need to work with the static side of the class directly. In this example, we define two interfaces, ClockConstructor for the constructor and ClockInterface for the instance methods. Then for convenience we define a constructor function createClock that creates instances of the type that is passed to it.
-->
<p>这是因为当一个类实现一个接口的时候，只有类的实例侧会被检察。而构造函数属于静态侧，而不会被检察。<br>相反，你应该直接使用静态侧类型。在下面这个例子中我们定义了两个接口，用于构造函数的<code>ClockConstructor</code>和用于实例的<code>ClockInterface</code>.然后我们创建了<code>createClock</code>来创建传递给它的的类型的实例。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">interface</span> ClockConstructor &#123;</div><div class="line">    <span class="keyword">new</span> (hour: <span class="built_in">number</span>, minute: <span class="built_in">number</span>): ClockInterface;</div><div class="line">&#125;</div><div class="line"><span class="keyword">interface</span> ClockInterface &#123;</div><div class="line">    tick();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">createClock</span>(<span class="params">ctor: ClockConstructor, hour: <span class="built_in">number</span>, minute: <span class="built_in">number</span></span>): <span class="title">ClockInterface</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ctor(hour, minute);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">class</span> DigitalClock <span class="keyword">implements</span> ClockInterface &#123;</div><div class="line">    <span class="keyword">constructor</span>(<span class="params">h: <span class="built_in">number</span>, m: <span class="built_in">number</span></span>) &#123; &#125;</div><div class="line">    tick() &#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">"beep beep"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">class</span> AnalogClock <span class="keyword">implements</span> ClockInterface &#123;</div><div class="line">    <span class="keyword">constructor</span>(<span class="params">h: <span class="built_in">number</span>, m: <span class="built_in">number</span></span>) &#123; &#125;</div><div class="line">    tick() &#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">"tick tock"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> digital = createClock(DigitalClock, <span class="number">12</span>, <span class="number">17</span>);</div><div class="line"><span class="keyword">let</span> analog = createClock(AnalogClock, <span class="number">7</span>, <span class="number">32</span>);</div></pre></td></tr></table></figure>
<p>因为<code>createClock</code>的第一个参数是<code>ClockConstructor</code>类型，而<code>AnalogClock</code>的构造函数的类型和这个接口是兼容的，所以<code>createClock(AnalogClock,7,32)</code>是可以的。</p>
<h2 id="扩展接口"><a href="#扩展接口" class="headerlink" title="扩展接口"></a>扩展接口</h2><p>和类一样，接口也可以扩展其它的接口。这可以让你把一个接口的属性复制到另外一个接口中。这样就可以把接口拆分成可复用的组件。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">interface</span> Shape &#123;</div><div class="line">    color: <span class="built_in">string</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">interface</span> Square <span class="keyword">extends</span> Shape &#123;</div><div class="line">    sideLength: <span class="built_in">number</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> square = &lt;Square&gt;&#123;&#125;;</div><div class="line">square.color = <span class="string">"blue"</span>;</div><div class="line">square.sideLength = <span class="number">10</span>;</div></pre></td></tr></table></figure>
<p>一个接口可以扩展多个接口：<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">interface</span> Shape &#123;</div><div class="line">    color: <span class="built_in">string</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">interface</span> PenStroke &#123;</div><div class="line">    penWidth: <span class="built_in">number</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">interface</span> Square <span class="keyword">extends</span> Shape, PenStroke &#123;</div><div class="line">    sideLength: <span class="built_in">number</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> square = &lt;Square&gt;&#123;&#125;;</div><div class="line">square.color = <span class="string">"blue"</span>;</div><div class="line">square.sideLength = <span class="number">10</span>;</div><div class="line">square.penWidth = <span class="number">5.0</span>;</div></pre></td></tr></table></figure></p>
<h1 id="混合类型"><a href="#混合类型" class="headerlink" title="混合类型"></a>混合类型</h1><p>就像我们前面提到的那样，接口可以描述JavaScript中的丰富的类型。由于JavaScript的动态性和灵活性，你也许会遇到一个对象，它是好几种类型混合的结果。<br>例如，一个东西既是一个有属性的对象又是一个函数。<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">interface</span> Counter &#123;</div><div class="line">    (start: <span class="built_in">number</span>): <span class="built_in">string</span>;</div><div class="line">    interval: <span class="built_in">number</span>;</div><div class="line">    reset(): <span class="built_in">void</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getCounter</span>(<span class="params"></span>): <span class="title">Counter</span> </span>&#123;</div><div class="line">    <span class="keyword">let</span> counter = &lt;Counter&gt;<span class="function"><span class="keyword">function</span> (<span class="params">start: <span class="built_in">number</span></span>) </span>&#123; &#125;;</div><div class="line">    counter.interval = <span class="number">123</span>;</div><div class="line">    counter.reset = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; &#125;;</div><div class="line">    <span class="keyword">return</span> counter;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> c = getCounter();</div><div class="line">c(<span class="number">10</span>);</div><div class="line">c.reset();</div><div class="line">c.interval = <span class="number">5.0</span>;</div></pre></td></tr></table></figure></p>
<p>当你使用第三方JavaScript库的时候，你也许需要这一特性来完全描述对象的类型。</p>
<h1 id="接口扩展类"><a href="#接口扩展类" class="headerlink" title="接口扩展类"></a>接口扩展类</h1><p>当一个接口扩展只一个类，那么它继承了类的所有成员，但不包含这些成员的实现。表现的就像接口声明了这所有的接口，没有实现它们。接口甚至可以继承一到类的私有的或受保护的成员。这表明当你创建了一个继承了私有或受保护的成员，这个接口就只能被该类的子类实现。(注:原文说的是该接口只能被该类或其子类实现)<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Control &#123;</div><div class="line">    <span class="keyword">private</span> state: <span class="built_in">any</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">interface</span> SelectableControl <span class="keyword">extends</span> Control &#123;</div><div class="line">    select(): <span class="built_in">void</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">class</span> Button <span class="keyword">extends</span> Control <span class="keyword">implements</span> SelectableControl &#123;</div><div class="line">    select() &#123; &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">class</span> TextBox <span class="keyword">extends</span> Control &#123;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// Error: Property 'state' is missing in type 'Image'.</span></div><div class="line"><span class="keyword">class</span> Image <span class="keyword">implements</span> SelectableControl &#123;</div><div class="line">    select() &#123; &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">class</span> Location &#123;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<!--
In the above example, SelectableControl contains all of the members of Control, including the private state property. Since state is a private member it is only possible for descendants of Control to implement SelectableControl. This is because only descendants of Control will have a state private member that originates in the same declaration, which is a requirement for private members to be compatible.

Within the Control class it is possible to access the state private member through an instance of SelectableControl. Effectively, a SelectableControl acts like a Control that is known to have a select method. The Button and TextBox classes are subtypes of SelectableControl (because they both inherit from Control and have a select method), but the Image and Location classes are not.
-->
<p>在上面的例子中，<code>SelectableControl</code>包含了<code>Control</code>的所有成员，包私有的<code>state</code>成员。<code>state</code>是私有变量，只能在<code>Control</code>的子类中实现<code>SelectableControl</code>，这是因为<code>Control</code>的子类才有这些同处声明的私有成员，这是私有成员类型兼容的必要条件。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/10/13/var-declare/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Qianba">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Blogs">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/10/13/var-declare/" itemprop="url">2.变量声明</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-10-13T22:30:02+08:00">
                2017-10-13
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/翻译/" itemprop="url" rel="index">
                    <span itemprop="name">翻译</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/翻译/编程语言/" itemprop="url" rel="index">
                    <span itemprop="name">编程语言</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/翻译/编程语言/TypeScript/" itemprop="url" rel="index">
                    <span itemprop="name">TypeScript</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="变量声明"><a href="#变量声明" class="headerlink" title="变量声明"></a>变量声明</h1><p><code>let</code> 和<code>const</code>是JavaScript中的两种声明方式。就像前文说过的那样，在某些方面<code>let</code>和<code>var</code>是相似的，但是使用<code>let</code>可以避免许多JavaScript程序员常常遇见的陷阱。<code>const</code> 是对<code>let</code>的增强，它可以防止对变量的从新赋值。</p>
<p>TypeScript是JavaScript的超集，所以<code>let</code>和<code>const</code>在TypeScript中自然可用。本文将会仔细介绍这两种声明方式，。。。</p>
<h1 id="var-声明方式"><a href="#var-声明方式" class="headerlink" title="var 声明方式"></a>var 声明方式</h1><p>在JavaScript中一直(注：ES6之前)使用var关键字来声明变量。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var a=10;</div></pre></td></tr></table></figure></p>
<p>就如你所想，这里声明了一个叫<code>a</code>的变量，并且赋值10给它。<br>我们也可以在函数中声明一个变量：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> message = <span class="string">"Hello, world!"</span>;</div><div class="line">    <span class="keyword">return</span> message;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我们也可以在内嵌的其它函数中访问这些变量：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> a = <span class="number">10</span>;</div><div class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">g</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">var</span> b = a + <span class="number">1</span>;</div><div class="line">        <span class="keyword">return</span> b;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> g = f();</div><div class="line">g(); <span class="comment">// returns '11'</span></div></pre></td></tr></table></figure></p>
<p>这段代码中，函数g捕获了变量a，当g被调用的时候，尽管这时候f的调用已经完成了，a都可以被访问，就像f中的代码访问a一样。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> a = <span class="number">1</span>;</div><div class="line"></div><div class="line">    a = <span class="number">2</span>;</div><div class="line">    <span class="keyword">var</span> b = g();</div><div class="line">    a = <span class="number">3</span>;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> b;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">g</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> a;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">f(); <span class="comment">// returns '2'</span></div></pre></td></tr></table></figure></p>
<h1 id="作用域规则"><a href="#作用域规则" class="headerlink" title="作用域规则"></a>作用域规则</h1><p>var 声明方式拥有其它语言没有的奇怪的作用域（注:），举例来说：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">shouldInitialize: boolean</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (shouldInitialize) &#123;</div><div class="line">        <span class="keyword">var</span> x = <span class="number">10</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> x;</div><div class="line">&#125;</div><div class="line"></div><div class="line">f(<span class="literal">true</span>);  <span class="comment">// returns '10'</span></div><div class="line">f(<span class="literal">false</span>); <span class="comment">// returns 'undefined'</span></div></pre></td></tr></table></figure></p>
<p>有些读者对于这个例子可能要多思考两次（即懵一下），变量<code>x</code>在if块中声明，但我们却能在if块的外面访问它（注：在常见的语言中会有一个编译时错误：x 未声明）！导致这一现象的原因是，var 方式声明的变量在其声明所在的函数、模块或全局作用域总是可见的。有人把这称为var作用域或函数作用域。函数参数也是函数作用域。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">sumMatrix</span>(<span class="params">matrix: number[][]</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> sum = <span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; matrix.length; i++) &#123;</div><div class="line">        <span class="keyword">var</span> currentRow = matrix[i];</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; currentRow.length; i++) &#123;</div><div class="line">            sum += currentRow[i];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> sum;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>有了上面的经验，有的读者可能容易看出问题所在。最内的for循环的<code>i</code>覆盖了外层i的值，因为i的作用域在这整个函数！类似的bug不容易在code review时（注：代码审查，开发环节）被发现，而成为问题之源。</p>
<h1 id="变量捕获的怪异行为"><a href="#变量捕获的怪异行为" class="headerlink" title="变量捕获的怪异行为"></a>变量捕获的怪异行为</h1><p>快速指出下列代码的输出：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</div><div class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(i); &#125;, <span class="number">100</span> * i);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>(致不熟悉setTimeout的人：setTimeout会在指定的多少毫秒后执行指定的函数）</p>
<p>答案是什么呢？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">10</div><div class="line">10</div><div class="line">10</div><div class="line">10</div><div class="line">10</div><div class="line">10</div><div class="line">10</div><div class="line">10</div><div class="line">10</div><div class="line">10</div></pre></td></tr></table></figure></p>
<p>许多JavaScript开发人员熟知JavaScript的这一特性，但如果你有些诧异，你也不孤单，因为很多人以为的输出是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">0</div><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td></tr></table></figure></p>
<p>还记得前面提过的变量捕获吗？每一个传递给setTimeout的函数捕获了同作用域下的同一个变量i。<br>让我们稍稍想一下这意味着什么。setTimeout 会在若干毫秒后执行传给它的函数（注：哪怕是setTime(fn,0),请参考《异步JavaScript》）,这时候for循环已经完成，i 是 10。所以，之后运行的函数（setTimeout的回调）输出都是10。</p>
<p>一个常用的解决方案是在每次循环中用<code>立即执行函数表达式(IIFE,Immediately Invoked Function Expression)</code>来捕获<code>i</code><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</div><div class="line">    <span class="comment">// capture the current state of 'i'</span></div><div class="line">    <span class="comment">// by invoking a function with its current value</span></div><div class="line">    (<span class="function"><span class="keyword">function</span>(<span class="params">i</span>) </span>&#123;<span class="comment">//在了的i覆盖了上层作用域的i</span></div><div class="line">        setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(i); &#125;, <span class="number">100</span> * i);</div><div class="line">    &#125;)(i);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这种看起来奇奇怪怪的模式实际上是非常通用的。参数i实际上覆盖了for循环中的i，只是名字相同而矣（注：若理解起来别扭，把IIFE内部的i改成j)。</p>
<blockquote>
<p>如下<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</div><div class="line">    <span class="comment">// capture the current state of 'i'</span></div><div class="line">    <span class="comment">// by invoking a function with its current value</span></div><div class="line">    (<span class="function"><span class="keyword">function</span>(<span class="params">j</span>) </span>&#123;</div><div class="line">        setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(j); &#125;, <span class="number">100</span> * j);</div><div class="line">    &#125;)(i);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
</blockquote>
<h1 id="let-方式声明"><a href="#let-方式声明" class="headerlink" title="let 方式声明"></a><code>let</code> 方式声明</h1><p>现在，你已经知道<code>var</code>的这些问题了，这也正是<code>let</code>被引入的原因，除了关键字不同，两种声明的写法是一样的：<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> hello = <span class="string">"Hello!"</span>;</div></pre></td></tr></table></figure></p>
<p>关键的区别不在于语法，而在于语义——我们即将介绍。</p>
<h1 id="块作用域"><a href="#块作用域" class="headerlink" title="块作用域"></a>块作用域</h1><p>当一个变量用<code>let</code>声明后，它使用所谓的<code>词法作用域</code>（或称<code>块作用域</code>）.不同于<code>var</code> 会将作用域“泄露”到其所在函数，块作用域只在其块内可见，例如for循环体。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">input: <span class="built_in">boolean</span></span>) </span>&#123;</div><div class="line">    <span class="keyword">let</span> a = <span class="number">100</span>;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (input) &#123;</div><div class="line">        <span class="comment">// Still okay to reference 'a'</span></div><div class="line">        <span class="keyword">let</span> b = a + <span class="number">1</span>;</div><div class="line">        <span class="keyword">return</span> b;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// Error: 'b' doesn't exist here</span></div><div class="line">    <span class="keyword">return</span> b;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在段代码中，我们声明了两个变量——a、b，a的作用域在f的函数体内，而b的作用域在if的语句块内。</p>
<p>在catch语句中声明的变量也有自己的块作用域：<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">    <span class="keyword">throw</span> <span class="string">"oh no!"</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">catch</span> (e) &#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"Oh well."</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// Error: 'e' doesn't exist here</span></div><div class="line"><span class="built_in">console</span>.log(e);</div></pre></td></tr></table></figure></p>
<p>块作用域变量的另一个性质是在其声明前是不可以被读写的。（注：有句废话没翻译）</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">a++; <span class="comment">// illegal to use 'a' before it's declared;</span></div><div class="line"><span class="keyword">let</span> a;</div></pre></td></tr></table></figure>
<p>值得注意的是，对于块级变量，你仍可以在声明前捕获它。<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">aFun</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(a);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// illegal call 'foo' before 'a' is declared</span></div><div class="line">    <span class="comment">// runtimes should throw an error here</span></div><div class="line">    <span class="comment">/*</span></div><div class="line"><span class="comment">     * 注：是否有runtime错误要看tsc编译参数，如果编译成ES5及更早版本则没有runtime错误</span></div><div class="line"><span class="comment">     * 请对比（徦设文件名为test.ts）：</span></div><div class="line"><span class="comment">     * tsc -t ES5 test.ts </span></div><div class="line"><span class="comment">     * tsc -t ES2016 test.ts</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    foo();</div><div class="line">    <span class="keyword">let</span> a=<span class="number">1</span>;</div><div class="line">    <span class="keyword">return</span> foo;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="重声明以及覆盖"><a href="#重声明以及覆盖" class="headerlink" title="重声明以及覆盖"></a>重声明以及覆盖</h1><p>上文提及的var方式声明的变量可以在同一作用域被声明多次，而不会报错：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">function f(x) &#123;</div><div class="line">    var x;</div><div class="line">    var x;</div><div class="line"></div><div class="line">    if (true) &#123;</div><div class="line">        var x;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在这个例子中，所有对<code>x</code>的声明都指向了同一个<code>x</code>，这样做的后果常常是成为了bug之源。因此,<code>let</code>不允许这样的声明。<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> x = <span class="number">10</span>;</div><div class="line"><span class="keyword">let</span> x = <span class="number">20</span>; <span class="comment">// error: can't re-declare 'x' in the same scope</span></div></pre></td></tr></table></figure></p>
<p>TypeScript 会告诉我们，同一个块作用域不能有两个同名的变量。<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x</span>) </span>&#123;</div><div class="line">    <span class="keyword">let</span> x = <span class="number">100</span>; <span class="comment">// error: interferes with parameter declaration</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">g</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">let</span> x = <span class="number">100</span>;</div><div class="line">    <span class="keyword">var</span> x = <span class="number">100</span>; <span class="comment">// error: can't have both declarations of 'x'</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>当然如果是父——子作用域是可以的：<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">condition, x</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (condition) &#123;</div><div class="line">        <span class="keyword">let</span> x = <span class="number">100</span>;</div><div class="line">        <span class="keyword">return</span> x;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> x;</div><div class="line">&#125;</div><div class="line"></div><div class="line">f(<span class="literal">false</span>, <span class="number">0</span>); <span class="comment">// returns '0'</span></div><div class="line">f(<span class="literal">true</span>, <span class="number">0</span>);  <span class="comment">// returns '100'</span></div></pre></td></tr></table></figure></p>
<p>这种在子作用域声明一个和父作用域同名的变量的形为就是——变量覆盖（shadowing)。这是一把双刃剑，在“不小心”覆盖了另一个变量的时候就可能会引入一些bug，同时变量覆盖也能访止一些bug，如前面的<code>sumMatrix</code><br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">sumMatrix</span>(<span class="params">matrix: <span class="built_in">number</span>[][]</span>) </span>&#123;</div><div class="line">    <span class="keyword">let</span> sum = <span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; matrix.length; i++) &#123;</div><div class="line">        <span class="keyword">var</span> currentRow = matrix[i];</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; currentRow.length; i++) &#123;</div><div class="line">            sum += currentRow[i];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> sum;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这段代码是能够完成矩阵求和的，因为内层for循环的i覆盖了外层循环的i，那么外层的i就不会被意外的修改了。</p>
<p>在意于写清晰明了的代码的时候应该必免使用变量覆盖这一特性。尽管在有些场合，这一特性会带来一些优势，你最好仔细考量。</p>
<h1 id="块作用域变量捕获"><a href="#块作用域变量捕获" class="headerlink" title="块作用域变量捕获"></a>块作用域变量捕获</h1><p>当我们首次了解var变量的捕获的情况的时候，我们粗略的调查了变量<br>被捕获后的形为。详细说来，每当一个作用域（中的代码）在执行的时候，有一个包含变量的“环境”被创建出来。这个环境和其捕获的变量在其所在的作用域执行完成后依然可以存在！<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">theCityThatAlwaysSleeps</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">let</span> getCity;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (<span class="literal">true</span>) &#123;</div><div class="line">        <span class="keyword">let</span> city = <span class="string">"Seattle"</span>;</div><div class="line">        getCity = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">            <span class="keyword">return</span> city;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> getCity();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>因为我们捕获了<code>city</code>变量，所以在if块执行之后我们仍可以访问它。<br>回想前面<code>setTimeout</code>那个例子，我们需要使用IIFE来捕获变量。<br>实际上，我们创建了一个新的变量环境来捕获变绿。IIFE的方式写起来有些老火，幸运的是在TypeScript中不必那样。<br><code>let</code>方式在循环语句中声明的变量很是不同，除了创建一个新的环境，这类声明（指let和const）也会在每次循环的时候创建一个新的作用域，这正是我们使用IIFE所作的事情。修改一下<code>setTimeout</code>那个例子，使用<code>let</code>来声明变量：<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span> ; i++) &#123;</div><div class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(i); &#125;, <span class="number">100</span> * i);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>输出则入我们所想的那样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">0</div><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td></tr></table></figure></p>
<h1 id="const-声明"><a href="#const-声明" class="headerlink" title="const 声明"></a>const 声明</h1><p>const是声明变量的另一种形式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">const numLivesForCat = 9;</div></pre></td></tr></table></figure></p>
<p>它和let很像，但是，就像其名字所暗示的那样，其值是不能够被修改的。换句话说，<code>const</code>和<code>let</code>具有一样的作用域规则，但是你不能为之重赋值。</p>
<p>可别和<code>不可变（immutable）</code>相混淆：<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> numLivesForCat = <span class="number">9</span>;</div><div class="line"><span class="keyword">const</span> kitty = &#123;</div><div class="line">    name: <span class="string">"Aurora"</span>,</div><div class="line">    numLives: numLivesForCat,</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// Error</span></div><div class="line">kitty = &#123;</div><div class="line">    name: <span class="string">"Danielle"</span>,</div><div class="line">    numLives: numLivesForCat</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">// all "okay"</span></div><div class="line">kitty.name = <span class="string">"Rory"</span>;</div><div class="line">kitty.name = <span class="string">"Kitty"</span>;</div><div class="line">kitty.name = <span class="string">"Cat"</span>;</div><div class="line">kitty.numLives--;</div></pre></td></tr></table></figure></p>
<p>除非你采取了特殊措施，<code>const</code>变量的内部状态（注：对像的属性，数组的元素等）是可变的（注：const 变量指的是引用不变）。所幸，TypeScript可指定属性为<code>readonly</code>来避免属性被修改。<a href="">接口</a>章会详述这个问题。</p>
<h1 id="let-vs-const"><a href="#let-vs-const" class="headerlink" title="let vs. const"></a><code>let</code> vs. <code>const</code></h1><p>设计两种具有相似作用域语义的变量声明方式，这使我们自然会问“使用哪个?”。答案和很多问题一样：看情况。</p>
<p>根据<a href="https://en.wikipedia.org/wiki/Principle_of_least_privilege" target="_blank" rel="external">最少特权原则</a>,所有无计划修改的变量应声明成<code>const</code>。原因是，如果一个变量不需要被修改，那么其头代码也不应有能修改这些变量的能力，也需要思考它们是否真得需要重赋值这些变量。使用<code>const</code>也使的在推算数据流的时候（注：即在脑中执行代码）代码的行为更可被预测。</p>
<p>[placeholder]</p>
<h1 id="解构"><a href="#解构" class="headerlink" title="解构"></a>解构</h1><p>TypeScript拥有的es2015的另一个特性是<code>解构</code>。[这里]是关于解构的完整说明，本节将大略的描述解构。</p>
<h2 id="数组解构"><a href="#数组解构" class="headerlink" title="数组解构"></a>数组解构</h2><p>最简单的数组解构是数组的解构赋值。<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> input = [<span class="number">1</span>, <span class="number">2</span>];</div><div class="line"><span class="keyword">let</span> [first, second] = input;</div><div class="line"><span class="built_in">console</span>.log(first); <span class="comment">// outputs 1</span></div><div class="line"><span class="built_in">console</span>.log(second); <span class="comment">// outputs 2</span></div></pre></td></tr></table></figure></p>
<p>这里创建了两个变量，first和second，和使用索引的方式效果一个，但是更加方便。<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">first = input[<span class="number">0</span>];</div><div class="line">second = input[<span class="number">1</span>];</div></pre></td></tr></table></figure></p>
<p>解构赋值也可使用在已经声明的变量上，<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// swap variables</span></div><div class="line">[first, second] = [second, first];</div></pre></td></tr></table></figure></p>
<p>以及用在函数的参数中：<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">[first, second]: [<span class="built_in">number</span>, <span class="built_in">number</span>]</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(first);</div><div class="line">    <span class="built_in">console</span>.log(second);</div><div class="line">&#125;</div><div class="line">f([<span class="number">1</span>, <span class="number">2</span>]);</div></pre></td></tr></table></figure></p>
<p>你可以使用…语法来创建一个list变量来保存剩余元素：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> [first, ...rest] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</div><div class="line"><span class="built_in">console</span>.log(first); <span class="comment">// outputs 1</span></div><div class="line"><span class="built_in">console</span>.log(rest); <span class="comment">// outputs [ 2, 3, 4 ]</span></div></pre></td></tr></table></figure>
<p>当然，你也可以忽略你不关心的尾部的元素。<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> [first] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</div><div class="line"><span class="built_in">console</span>.log(first); <span class="comment">// outputs 1</span></div></pre></td></tr></table></figure></p>
<p>当然，其它元素也是可忽略的：<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> [, second, , fourth] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</div></pre></td></tr></table></figure></p>
<h2 id="对象解构"><a href="#对象解构" class="headerlink" title="对象解构"></a>对象解构</h2><p>你也可以解构对象：<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> o = &#123;</div><div class="line">    a: <span class="string">"foo"</span>,</div><div class="line">    b: <span class="number">12</span>,</div><div class="line">    c: <span class="string">"bar"</span></div><div class="line">&#125;;</div><div class="line"><span class="keyword">let</span> &#123; a, b &#125; = o;</div></pre></td></tr></table></figure></p>
<p>这里从a对象创建了a、b变量，其值分别是<code>o.a</code>,<code>o.b</code>并忽略了<code>a.c</code>。</p>
<p>和数组解构一样你也可以不要声明而赋值：<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(&#123; a, b &#125; = &#123; a: <span class="string">"baz"</span>, b: <span class="number">101</span> &#125;);</div></pre></td></tr></table></figure></p>
<p>注意，我们必须用园括号把代码包起来，js会把{作为块来解析<br>你也可以使用<code>...</code>语法来创建一个包含其它未被解构属性的变量</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> &#123; a, ...passthrough &#125; = o;</div><div class="line"><span class="keyword">let</span> total = passthrough.b + passthrough.c.length;</div></pre></td></tr></table></figure>
<h3 id="属性重命名"><a href="#属性重命名" class="headerlink" title="属性重命名"></a>属性重命名</h3><p>你也可以给属性一个不同的名字<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> &#123; a: newName1, b: newName2 &#125; = o;</div></pre></td></tr></table></figure></p>
<p>这种语法开始让人有点迷糊，你可以把<code>a:newName1</code>解释为<code>newName1是a</code>,这和下面的代码是等价的：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> newName1 = o.a;</div><div class="line"><span class="keyword">let</span> newName2 = o.b;</div></pre></td></tr></table></figure>
<p>这里的<code>：</code>不是表示类型，如果你想指定变量的类型，那么需要在整个解构后。</p>
<h3 id="默认值"><a href="#默认值" class="headerlink" title="默认值"></a>默认值</h3><p>默认值可以在某个属性是undefined的时候指定一个默认的值。<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">keepWholeObject</span>(<span class="params">wholeObject: &#123; a: <span class="built_in">string</span>, b?: <span class="built_in">number</span> &#125;</span>) </span>&#123;</div><div class="line">    <span class="keyword">let</span> &#123; a, b = <span class="number">1001</span> &#125; = wholeObject;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里,在函数<code>keepWholeObject</code>中有变量:<code>a</code>,<code>b</code>,以及<code>wholeObject</code>。</p>
<h3 id="函数声明"><a href="#函数声明" class="headerlink" title="函数声明"></a>函数声明</h3><p>解构也可用在函数的声明中，如下例：<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> C = &#123; a: <span class="built_in">string</span>, b?: <span class="built_in">number</span> &#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">&#123; a, b &#125;: C</span>): <span class="title">void</span> </span>&#123;</div><div class="line">    <span class="comment">// ...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>[placeholder]</p>
<h2 id="延展"><a href="#延展" class="headerlink" title="延展"></a>延展</h2><blockquote>
<p>不知道spread对应的术语，乱译为<code>延展</code></p>
</blockquote>
<p>spread运算和解构运算作用是相对的，它可以把一个数组中的元素放到其他数组中。或者把一个对象的属性放到其它对象中。<br>比如：<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> first = [<span class="number">1</span>, <span class="number">2</span>];</div><div class="line"><span class="keyword">let</span> second = [<span class="number">3</span>, <span class="number">4</span>];</div><div class="line"><span class="keyword">let</span> bothPlus = [<span class="number">0</span>, ...first, ...second, <span class="number">5</span>];</div></pre></td></tr></table></figure></p>
<p><code>bothPlus</code>数组为[0,1,2,3,4,5],<code>Spread</code>创建了<code>first</code>和<code>second</code>的<strong>浅拷贝</strong><br>你也可以<code>spread</code>一个对象<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> defaults = &#123; food: <span class="string">"spicy"</span>, price: <span class="string">"$$"</span>, ambiance: <span class="string">"noisy"</span> &#125;;</div><div class="line"><span class="keyword">let</span> search = &#123; ...defaults, food: <span class="string">"rich"</span> &#125;;</div></pre></td></tr></table></figure></p>
<p><code>search</code>为<code>{ food: &quot;rich&quot;, price: &quot;$$&quot;, ambiance: &quot;noisy&quot; }</code>,对象的延展比数组的延展要复杂一些。和数组延展一样，处理的过程是“从左到右的”,只是处理的结果仍然是一个数组而矣。这意味着，后出现的属性将覆盖先出现的属性。所以，如果我们修改上面的例子：<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> defaults = &#123; food: <span class="string">"spicy"</span>, price: <span class="string">"$$"</span>, ambiance: <span class="string">"noisy"</span> &#125;;</div><div class="line"><span class="keyword">let</span> search = &#123; food: <span class="string">"rich"</span>, ...defaults &#125;;</div></pre></td></tr></table></figure></p>
<p>那么得到的search的food属性的值将会是<code>spicy</code>。</p>
<p>对象延展还有一些限制，结果只会包含对象<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Enumerability_and_ownership_of_properties" target="_blank" rel="external">自身的、可枚举的属性</a>(注：自身的表示非原型链上的属性)<br>所以，当你延展一个对象时，将丢失其上的方法。<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> C &#123;</div><div class="line">  p = <span class="number">12</span>;</div><div class="line">  m() &#123;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">let</span> c = <span class="keyword">new</span> C();</div><div class="line"><span class="keyword">let</span> clone = &#123; ...c &#125;;</div><div class="line">clone.p; <span class="comment">// ok</span></div><div class="line">clone.m(); <span class="comment">// error!</span></div></pre></td></tr></table></figure></p>
<p>此外，Typescript编译器不允许泛型函数的类型参数。这一特型在将来的版本中可能会受支持。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/10/10/bacis-types/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Qianba">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Blogs">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/10/10/bacis-types/" itemprop="url">1.基本类型</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-10-10T17:32:03+08:00">
                2017-10-10
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/翻译/" itemprop="url" rel="index">
                    <span itemprop="name">翻译</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/翻译/编程语言/" itemprop="url" rel="index">
                    <span itemprop="name">编程语言</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/翻译/编程语言/TypeScript/" itemprop="url" rel="index">
                    <span itemprop="name">TypeScript</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Boolean"><a href="#Boolean" class="headerlink" title="Boolean"></a>Boolean</h1><p>最基本的数据类型为简单的true/false值，在TypeScript中被称为<code>boolean</code> 值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">let isDone:boolean = false;</div></pre></td></tr></table></figure></p>
<h1 id="Number"><a href="#Number" class="headerlink" title="Number"></a>Number</h1><p>和JavaScript 一样，所有数字都是浮点数，即<code>number</code>类型<br>除了十六进制和十进制字面量，TypeScript也支持ECMAScript 2015引入的二进制和八进制字面量</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> decimal: <span class="built_in">number</span> = <span class="number">6</span>;</div><div class="line"><span class="keyword">let</span> hex: <span class="built_in">number</span> = <span class="number">0xf00d</span>;</div><div class="line"><span class="keyword">let</span> binary: <span class="built_in">number</span> = <span class="number">0b1010</span>;</div><div class="line"><span class="keyword">let</span> octal: <span class="built_in">number</span> = <span class="number">0o744</span>;</div></pre></td></tr></table></figure>
<h1 id="String"><a href="#String" class="headerlink" title="String"></a>String</h1><p>在JavaScript中，编写程序的一项基本工作是对文本数据的处理。和其它的语言一样，我们使用<code>string</code>来表示这些文本数据类型。和JavaScript一样，TypeScript也使用双引号和单引号来表示字符串数据。<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> color: <span class="built_in">string</span> = <span class="string">"blue"</span>;</div><div class="line">color = <span class="string">'red'</span>;</div></pre></td></tr></table></figure></p>
<p>你也可以使用<code>模版字符串</code>,在模版字符串中可以嵌入表达式，同时，模版串内可以换行。模版串用反引号来表示，其内嵌的表达式形如<code>${ expression }</code></p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> fullName: <span class="built_in">string</span> = <span class="string">`Bob Bobbington`</span>;</div><div class="line"><span class="keyword">let</span> age: <span class="built_in">number</span> = <span class="number">37</span>;</div><div class="line"><span class="keyword">let</span> sentence: <span class="built_in">string</span> = <span class="string">`Hello, my name is <span class="subst">$&#123; fullName &#125;</span>.</span></div><div class="line"><span class="string"></span></div><div class="line"><span class="string">I'll be <span class="subst">$&#123; age + 1 &#125;</span> years old next month.`</span>;</div></pre></td></tr></table></figure>
<p>这和按如下方式定义<code>sentence</code> 等价：<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> sentence: <span class="built_in">string</span> = <span class="string">"Hello, my name is "</span> + fullName + <span class="string">".\n\n"</span> +</div><div class="line">    <span class="string">"I'll be "</span> + (age + <span class="number">1</span>) + <span class="string">" years old next month."</span>;</div></pre></td></tr></table></figure></p>
<h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><p>和JavaScript一样，TypeScript允许你使用数组。数组的类型可有两种写法。<br>第一种是在元素类型的后面跟上一对方括号：<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> list:<span class="built_in">number</span>[] = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</div></pre></td></tr></table></figure></p>
<p>第二种是使用泛型数组参数:<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> list:<span class="built_in">Array</span>&lt;<span class="built_in">number</span>&gt; = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</div></pre></td></tr></table></figure></p>
<h1 id="元组-Tuple"><a href="#元组-Tuple" class="headerlink" title="元组(Tuple)"></a>元组(Tuple)</h1><p>一个数组元素个数固定且类型已知，用元组来表示。例如，你可能需要表示一个<code>string</code>和一个<code>number</code>构成的二元组<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Declare a tuple type</span></div><div class="line"><span class="keyword">let</span> x: [<span class="built_in">string</span>, <span class="built_in">number</span>];</div><div class="line"><span class="comment">// Initialize it</span></div><div class="line">x = [<span class="string">"hello"</span>, <span class="number">10</span>]; <span class="comment">// OK</span></div><div class="line"><span class="comment">// Initialize it incorrectly</span></div><div class="line">x = [<span class="number">10</span>, <span class="string">"hello"</span>]; <span class="comment">// Error</span></div></pre></td></tr></table></figure></p>
<p>当我们访问一个索引已知的元组元素，那么这个元素的类型也就是已知的了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">console.log(x[0].substr(1)); // OK</div><div class="line">console.log(x[1].substr(1)); // Error, &apos;number&apos; does not have &apos;substr&apos; typescript 知道x[1]是一个number类型的东西</div></pre></td></tr></table></figure></p>
<p>当访问元组索引范围外的元素的时候，TypeScript会将其视为该元组已知类型的<code>并类型(Union types)</code>.<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">x[<span class="number">3</span>] = <span class="string">"world"</span>; <span class="comment">// OK, 'string' can be assigned to 'string | number'</span></div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(x[<span class="number">5</span>].toString()); <span class="comment">// OK, 'string' and 'number' both have 'toString'</span></div><div class="line"></div><div class="line">x[<span class="number">6</span>] = <span class="literal">true</span>; <span class="comment">// Error, 'boolean' isn't 'string | number'</span></div></pre></td></tr></table></figure></p>
<p>并类型是一个高级话题，将在后文讨论。</p>
<h1 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h1><p>除了JavaScript的数据类型，TypeScript还增加了一种有用的类型——枚举(enum). 和C#一样，枚举是给一组数字取一个友好的名字的方式。（注: typescript 2.4 中枚举也可以是字符串)<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">enum</span> Color &#123;Red, Green, Blue&#125;</div><div class="line"><span class="keyword">let</span> c: Color = Color.Green;</div></pre></td></tr></table></figure></p>
<p>默认情况下，枚举值从0开始(后续加1)。你可以手动为枚举的某个成员设置一个值来改变其默认的值。<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">enum</span> Color &#123;Red = <span class="number">1</span>, Green, Blue&#125; </div><div class="line"><span class="keyword">let</span> c: Color = Color.Green; <span class="comment">// 2</span></div></pre></td></tr></table></figure></p>
<p>或者，可以为枚举的每个成员设置值。<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">enum</span> Color &#123;Red = <span class="number">1</span>, Green = <span class="number">2</span>, Blue = <span class="number">4</span>&#125;</div><div class="line"><span class="keyword">let</span> c: Color = Color.Green;</div></pre></td></tr></table></figure></p>
<p>一个方便的特性是你根据枚举值得到其对应的名字.<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">enum</span> Color &#123;Red = <span class="number">1</span>, Green, Blue&#125;</div><div class="line"><span class="keyword">let</span> colorName: <span class="built_in">string</span> = Color[<span class="number">2</span>];</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(colorName); <span class="comment">// Green</span></div></pre></td></tr></table></figure></p>
<h1 id="Any-类型"><a href="#Any-类型" class="headerlink" title="Any 类型"></a>Any 类型</h1><p>我们也许需要描述这样一种变量——我们在写程序的时候并不知道其类型，这些变量值可能来自一些动态的内容，例如——第三方库。这种情况，我们想对这些变量停用类型检察以便通过编译。为了做到这点，我们使用<code>any</code> 类型<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> notSure: <span class="built_in">any</span> = <span class="number">4</span>;</div><div class="line">notSure = <span class="string">"maybe a string instead"</span>;</div><div class="line">notSure = <span class="literal">false</span>; <span class="comment">// okay, definitely a boolean</span></div></pre></td></tr></table></figure></p>
<p>any 类型是和JavaScript库交互的有效方式，这可让你逐渐的启用或停用类型检察。你也许希望<code>Object</code>类现会扮演同样的角色，在其它某些语言中的却如此。但在typescript中，Object类型的变量只允许你将any类型的变量赋值给它，而不能调用上面的任意方法，那怕是的确存在的方法。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> notSure: <span class="built_in">any</span> = <span class="number">4</span>;</div><div class="line">notSure.ifItExists(); <span class="comment">// okay, ifItExists might exist at runtime</span></div><div class="line">notSure.toFixed(); <span class="comment">// okay, toFixed exists (but the compiler doesn't check)</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> prettySure: <span class="built_in">Object</span> = <span class="number">4</span>;</div><div class="line">prettySure.toFixed(); <span class="comment">// Error: Property 'toFixed' doesn't exist on type 'Object'.</span></div></pre></td></tr></table></figure>
<h1 id="Void-类型"><a href="#Void-类型" class="headerlink" title="Void 类型"></a>Void 类型</h1><p>void有些像是和any相反，它表示——没有类型。你可能常在函数的返回值类型声明的地方见到该类型。<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">warnUser</span>(<span class="params"></span>): <span class="title">void</span> </span>&#123;</div><div class="line">    alert(<span class="string">"This is my warning message"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>用void来声明变量就没什么意义了，因为你只能给它赋<code>undefined</code>或<code>null</code>给它。</p>
<h1 id="Null-和-Undefined"><a href="#Null-和-Undefined" class="headerlink" title="Null 和 Undefined"></a>Null 和 Undefined</h1><p>默认情况下，null和undefined 是所有其它类型的子类型，所以null和undefined可以赋值给任何变量。<br>但当<code>--strictNullChecks</code>选项启用后，null和undefined就只能够赋值给<code>void</code>或其对应的类型（注：null，undefined 即是类型，也是值）。这有助于避免多数常见错误。<br>当你希望传递string或null或undefined的类型的值的时候则需要使用并类型 <code>string | null | undefined</code>。</p>
<blockquote>
<p>推荐使用<code>--strictNullChecks</code>,但该教程徦设该选项是关闭了的。</p>
</blockquote>
<h1 id="Never-类型"><a href="#Never-类型" class="headerlink" title="Never 类型"></a>Never 类型</h1><p>never 类型代表了“<code>永远不会出现</code>”的类型，<code>never</code> 是那些总是抛出错误或永不返回的函数的“返回类型”()。<br>(Variables also acquire the type never when narrowed by any type guards that can never be true. ???)<br>never 类型也是所有类型的子类型，同时，没有类型是never类型的子类型，所以除了never自己，没有类型可以赋值给never。 any也不可以赋值给never。<br>函数返回类型为<code>never</code>的例子：<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Function returning never must have unreachable end point</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">error</span>(<span class="params">message: <span class="built_in">string</span></span>): <span class="title">never</span> </span>&#123;</div><div class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(message);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// Inferred return type is never</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">fail</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> error(<span class="string">"Something failed"</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// Function returning never must have unreachable end point</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">infiniteLoop</span>(<span class="params"></span>): <span class="title">never</span> </span>&#123;</div><div class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="类型断言"><a href="#类型断言" class="headerlink" title="类型断言"></a>类型断言</h1><p>有时候你会遇到这样的情况：你比TypeScript更清楚一个值是什么类型的。<br>类型断言是一种指定类型的方法，相当于告诉编译器：“相信我，我知道为在做什么”。类型断言和其它语言中的类型转换(type cast)是类似的，但不会执行特别的检察或数据重构操作。也没有运行时的开销，只是纯粹的为编译器使用而矣。TypeScript徦设你已经做过必要的检察了。<br>类型断言有两种形式，一种是<code>尖括号</code>语法:<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> someValue: <span class="built_in">any</span> = <span class="string">"this is a string"</span>;</div><div class="line"></div><div class="line"><span class="keyword">let</span> strLength: <span class="built_in">number</span> = (&lt;<span class="built_in">string</span>&gt;someValue).length;</div></pre></td></tr></table></figure></p>
<p>另一种是<code>as</code>语法：<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">    <span class="keyword">let</span> someValue: <span class="built_in">any</span> = <span class="string">"this is a string"</span>;</div><div class="line"></div><div class="line"><span class="keyword">let</span> strLength: <span class="built_in">number</span> = (someValue <span class="keyword">as</span> <span class="built_in">string</span>).length;</div></pre></td></tr></table></figure></p>
<p>这两种方式是等价的，使用哪种取决于你的偏好。但是，如果在TypeScript中使用JSX, 则只有<code>as</code>方式是可用的（注：JSX 用尖括号了表示组件，这会引入二意性）。</p>
<h1 id="关于-let"><a href="#关于-let" class="headerlink" title="关于 let"></a>关于 <code>let</code></h1><p>你可能注意到了，我们使用<code>let</code>关键字代替了JavaScript中的<code>var</code>关键字。let 实际上是JavaScript 新标准的东西，TypeScript使其提前可用了。后面我们会进一步讨论let，let可以缓解JavaScript中的很多问题，所以，尽可能使用let来代替var吧！</p>
<h1 id="进一步阅读"><a href="#进一步阅读" class="headerlink" title="进一步阅读"></a>进一步阅读</h1><p><a href="https://stackoverflow.com/questions/37910669/what-is-the-difference-between-never-and-void-in-typescript" target="_blank" rel="external">never 和 void 的区别</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  


          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="Qianba" />
          <p class="site-author-name" itemprop="name">Qianba</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">6</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              
                <span class="site-state-item-count">3</span>
                <span class="site-state-item-name">分类</span>
              
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              
                <span class="site-state-item-count">1</span>
                <span class="site-state-item-name">标签</span>
              
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Qianba</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.2"></script>



  
  

  
    <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.2"></script>

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.2"></script>



  


  




	





  





  






  





  

  

  

  

  

  

</body>
</html>
