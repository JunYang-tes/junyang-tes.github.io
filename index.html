<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.2" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Qianba, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.2" />






<meta property="og:type" content="website">
<meta property="og:title" content="Blogs">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Blogs">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Blogs">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/"/>





  <title>Blogs</title>
  














</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Blogs</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/10/26/interface/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Qianba">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Blogs">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/10/26/interface/" itemprop="url">3.接口</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-10-26T22:30:02+08:00">
                2017-10-26
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/翻译/" itemprop="url" rel="index">
                    <span itemprop="name">翻译</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/翻译/编程语言/" itemprop="url" rel="index">
                    <span itemprop="name">编程语言</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/翻译/编程语言/TypeScript/" itemprop="url" rel="index">
                    <span itemprop="name">TypeScript</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p>TypeScript的核心概念之一就是类型检查，Typescript的类型检查是基于值的“形状”而言的，这种类型被称为“鸭类型”或“结构化类型”（注：如果一种生物走起路来像鸭子，叫起来像鸭子，就认为它是鸭子）。在TypeScript中，是给类型“命名”的一种角色，也是种约束你的代码的有效方式。</p>
<h1 id="第一个接口"><a href="#第一个接口" class="headerlink" title="第一个接口"></a>第一个接口</h1><p>关于接口最简单的说明，如下例：<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">printLabel</span>(<span class="params">labelledObj: &#123; label: <span class="built_in">string</span> &#125;</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(labelledObj.label);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> myObj = &#123;size: <span class="number">10</span>, label: <span class="string">"Size 10 Object"</span>&#125;;</div><div class="line">printLabel(myObj);</div></pre></td></tr></table></figure></p>
<p>类型检查器检查对<code>printLabel</code>的调用，该函数需要一个参数，这个参数是一个有串类型的<code>label</code>属性的对象。调用时传递给该函数的参数实际上除了<code>label</code>属性，还有些其它属性。编译器只会确保有有相匹配的那些属性，但也有一些情况不是这样简单的处理。<br>我们可以改写这个例子，这次我们使用一个接口来描述<code>printLabel</code>的参数。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">interface</span> LabelledValue &#123;</div><div class="line">    label: <span class="built_in">string</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">printLabel</span>(<span class="params">labelledObj: LabelledValue</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(labelledObj.label);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> myObj = &#123;size: <span class="number">10</span>, label: <span class="string">"Size 10 Object"</span>&#125;;</div><div class="line">printLabel(myObj);</div></pre></td></tr></table></figure>
<p>现在我们可用<code>LabelledValue</code>这个接口来描述<code>printLabel</code>的参数。我们并没有明确的让传递给<code>printLabel</code>的参数要实现<code>LabelledValue</code>这个接口，在其它语言中可能需要这样做。这里只在乎的是“形状”。如果我们传递过去的东西和<code>LabelledValue</code>是兼容的就可以的。</p>
<p>值得说明的是，类型检察器不在意属性出现的顺序，只在有意识必要的那些属性以及这些属性的类型是正确的。</p>
<h1 id="可选属性"><a href="#可选属性" class="headerlink" title="可选属性"></a>可选属性</h1><p>接口中并不是每个属性都是必须的，有的属性在某些情况下才会出现，甚至不会出现。在使用所谓的“option bags”（注:即把所有的选项放在一个对象里面）的模式的时候可选属性是很常用的。<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">interface</span> SquareConfig &#123;</div><div class="line">    color?: <span class="built_in">string</span>;</div><div class="line">    width?: <span class="built_in">number</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">createSquare</span>(<span class="params">config: SquareConfig</span>): </span>&#123;color: <span class="built_in">string</span>; area: <span class="built_in">number</span>&#125; &#123;</div><div class="line">    <span class="keyword">let</span> newSquare = &#123;color: <span class="string">"white"</span>, area: <span class="number">100</span>&#125;;</div><div class="line">    <span class="keyword">if</span> (config.color) &#123;</div><div class="line">        newSquare.color = config.color;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (config.width) &#123;</div><div class="line">        newSquare.area = config.width * config.width;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> newSquare;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> mySquare = createSquare(&#123;color: <span class="string">"black"</span>&#125;);</div></pre></td></tr></table></figure></p>
<p>有可选属性的接口的语法和普通接口是类似的，只是每个可选属性的名字后面用一个<code>?</code>标记出来。</p>
<p>可选属性的优势是你可以描述那些可能出现的属性而且避免那些没有在接口中声明的属性(注:可防止拼写错误)。比如，我们把<code>color</code>错写成了<code>clor</code>，TypeScript将给出一个错误消息。<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">interface</span> SquareConfig &#123;</div><div class="line">    color?: <span class="built_in">string</span>;</div><div class="line">    width?: <span class="built_in">number</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">createSquare</span>(<span class="params">config: SquareConfig</span>): </span>&#123; color: <span class="built_in">string</span>; area: <span class="built_in">number</span> &#125; &#123;</div><div class="line">    <span class="keyword">let</span> newSquare = &#123;color: <span class="string">"white"</span>, area: <span class="number">100</span>&#125;;</div><div class="line">    <span class="keyword">if</span> (config.color) &#123;</div><div class="line">        <span class="comment">// Error: Property 'clor' does not exist on type 'SquareConfig'</span></div><div class="line">        newSquare.color = config.clor;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (config.width) &#123;</div><div class="line">        newSquare.area = config.width * config.width;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> newSquare;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> mySquare = createSquare(&#123;color: <span class="string">"black"</span>&#125;);</div></pre></td></tr></table></figure></p>
<h1 id="只读属性"><a href="#只读属性" class="headerlink" title="只读属性"></a>只读属性</h1><p>一些属性只应该在一个对象创建的时候被修改，你可以通过在属性名前加一个<code>readonly</code>关键字来说明这点。<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">interface</span> Point &#123;</div><div class="line">    readonly x: <span class="built_in">number</span>;</div><div class="line">    readonly y: <span class="built_in">number</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>你可以通过对象字面量的方式来创建<code>Point</code>对象，一旦创建对象后，就不再能修改<code>x</code>和<code>y</code>的值了。<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> p1: Point = &#123; x: <span class="number">10</span>, y: <span class="number">20</span> &#125;;</div><div class="line">p1.x = <span class="number">5</span>; <span class="comment">// error!</span></div></pre></td></tr></table></figure></p>
<p>TypeScript有一个<code>ReadonlyArray&lt;T&gt;</code>类型，基本和<code>Array&lt;T&gt;</code>一样，只不过那些修改类的方法被移除了，所以你可以确保数组在被创建之后就不再被修改了。<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> a: <span class="built_in">number</span>[] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</div><div class="line"><span class="keyword">let</span> ro: ReadonlyArray&lt;<span class="built_in">number</span>&gt; = a;</div><div class="line">ro[<span class="number">0</span>] = <span class="number">12</span>; <span class="comment">// error!</span></div><div class="line">ro.push(<span class="number">5</span>); <span class="comment">// error!</span></div><div class="line">ro.length = <span class="number">100</span>; <span class="comment">// error!</span></div><div class="line">a = ro; <span class="comment">// error!</span></div></pre></td></tr></table></figure></p>
<p>这段代码的最后一行表明，你不可以把一个ReadOnlyArray赋值给一个Array变量。<br>除非你使用类型断言:<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">a=ro <span class="keyword">as</span> <span class="built_in">number</span>[]</div></pre></td></tr></table></figure></p>
<p><strong>readonly</strong> vs <strong>const</strong><br>区别使用<code>readonly</code>还是<code>const</code>的最简单的方式是看是在属性上还是在变量上。前者使用<code>readonly</code>后者使用<code>const</code></p>
<h1 id="多余属性检查"><a href="#多余属性检查" class="headerlink" title="多余属性检查"></a>多余属性检查</h1><p>在我们的第一个例子中，我们把<code>{ size: number; label: string; }</code>传递给接受<code>{ label: string; }</code>的函数。我们也了解了可选属性，以及其在”option bags”时候的用处。<br>然而，这两者简单的合起来用却会遇到和JavaScript中一样的麻烦。例如:<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">interface</span> SquareConfig &#123;</div><div class="line">    color?: <span class="built_in">string</span>;</div><div class="line">    width?: <span class="built_in">number</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">createSquare</span>(<span class="params">config: SquareConfig</span>): </span>&#123; color: <span class="built_in">string</span>; area: <span class="built_in">number</span> &#125; &#123;</div><div class="line">    <span class="comment">// ...</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> mySquare = createSquare(&#123; colour: <span class="string">"red"</span>, width: <span class="number">100</span> &#125;);</div></pre></td></tr></table></figure></p>
<p>注意这里在调用<code>createSquare</code>时候传递的参数中用的是<code>colour</code>而非<code>color</code>.在JavaScript中，这种错误会静悄悄的发生。你会觉得你的程序是对的:<code>width</code>的类型是兼容的，没有<code>color</code>属性，多出一个<code>colour</code>属性。<br>然而，TypeScript的立场是这也许会是程序中的一个bug。<strong>*当一个对象被赋值 给其它变量，或通过参数传递的时候，对象会被特殊对待，经过所谓的”<code>多余属性检查</code>“</strong>。如果该对象含有目标类型所没有的属性，就会报错:<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// error: 'colour' not expected in type 'SquareConfig'</span></div><div class="line"><span class="keyword">let</span> mySquare = createSquare(&#123; colour: <span class="string">"red"</span>, width: <span class="number">100</span> &#125;);</div></pre></td></tr></table></figure></p>
<p>要通过这种检查也是十分简单的，使用类型断言就可以了:<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> mySquare = createSquare(&#123; width: <span class="number">100</span>, opacity: <span class="number">0.5</span> &#125; <span class="keyword">as</span> SquareConfig);</div></pre></td></tr></table></figure></p>
<p>但是，一个更好的方法是添加字符串索引签名(string index signature),当然，是在如果你确定被传递的对象是可有一些额外的属性的情况下。如果<code>SquareConfig</code>可有其它的属性，你可以这样定义它:<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">interface</span> SquareConfig &#123;</div><div class="line">    color?: <span class="built_in">string</span>;</div><div class="line">    width?: <span class="built_in">number</span>;</div><div class="line">    [propName: <span class="built_in">string</span>]: <span class="built_in">any</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>简单讨论一下索引签名。我们说<code>SquareConfig</code>可有任何数量的属性。只有这些属性的名字不是<code>color</code>和<code>width</code>，其类型是any。<br>还有一种通过检察的方式——这种放式可能会让人惊讶——把对象赋值给另外一个变量:<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> squareOptions = &#123; colour: <span class="string">"red"</span>, width: <span class="number">100</span> &#125;;</div><div class="line"><span class="keyword">let</span> mySquare = createSquare(squareOptions);</div></pre></td></tr></table></figure></p>
<p>因为<code>squareOptions</code>不会经历<code>多余属性检查</code>，那么也就不会有编译错误了。</p>
<p>记住，对于这段简单代码，你也许会认为不会通过检察。对于更复杂的对象字面量，它们有一些方法和状态变量，所以直接传递一个对象而非对象字面量的时候,TypeScript不会对其进行<code>多余属性检察</code>。而以对象字面量为<code>option bags</code>这样的参数的时候，<code>多余属性检察</code>的确可以必免很多bug.这也意味着，如果你在用<code>option bags</code>时遇到了<code>多余属性检察</code>报的错误，你也许就需要修改你的类型定义。例如，对于上面的例子，如果拥有<code>color</code>和<code>colour</code>属性的对象都可以作为<code>createSquare</code>的参数，那么你就需要修改<code>SquareConfig</code>的定义了。</p>
<h1 id="函数类型"><a href="#函数类型" class="headerlink" title="函数类型"></a>函数类型</h1><p>TypeScript中的<code>接口</code>这一概念可广泛的用来描述JavaScript中的东西。除了用来描述对象及其属性，接口也能用来描述函数的类型。</p>
<p>为了用接口来描述函数，我们给这些接口一个<code>调用签名</code>。这类似于函数的声明，参数表中的每个参数都要有类型和名字。<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">interface</span> SearchFunc &#123;</div><div class="line">    (source: <span class="built_in">string</span>, subString: <span class="built_in">string</span>): <span class="built_in">boolean</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>一旦定义了这样的接口，我们就可以像使用普通接口一样的使用它。<br>下面的例子演示了如何用函数接口来定义一个变量并为其赋值。<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> mySearch: SearchFunc;</div><div class="line">mySearch = <span class="function"><span class="keyword">function</span>(<span class="params">source: <span class="built_in">string</span>, subString: <span class="built_in">string</span></span>) </span>&#123;</div><div class="line">    <span class="keyword">let</span> result = source.search(subString);</div><div class="line">    <span class="keyword">return</span> result &gt; <span class="number">-1</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>对函数类型的类型检察不要求参数的名字相匹配:<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> mySearch: SearchFunc;</div><div class="line">mySearch = <span class="function"><span class="keyword">function</span>(<span class="params">src: <span class="built_in">string</span>, sub: <span class="built_in">string</span></span>): <span class="title">boolean</span> </span>&#123;</div><div class="line">    <span class="keyword">let</span> result = src.search(sub);</div><div class="line">    <span class="keyword">return</span> result &gt; <span class="number">-1</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如果将函数赋值给指明类型的变量，例如<code>SearchFunc</code>，而你没有指定参数的类型，TypeScript的<code>上下文类型</code>系统能够推断出参数的类型。<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> mySearch: SearchFunc;</div><div class="line">mySearch = <span class="function"><span class="keyword">function</span>(<span class="params">src, sub</span>) </span>&#123;</div><div class="line">    <span class="keyword">let</span> result = src.search(sub);</div><div class="line">    <span class="keyword">return</span> result &gt; <span class="number">-1</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里函数的返回值暗示了其类型(<code>false</code>或<code>true</code>).如果这里的返回值不是布尔类型的，TypeScript将会给出一个类型不匹配的警告。</p>
<h1 id="可索引的类型"><a href="#可索引的类型" class="headerlink" title="可索引的类型"></a>可索引的类型</h1><p>除了可用接口来描述函数，我们有可用接口来描述<code>索引</code>，类似于<code>a[10]</code>或<code>ageMap[&quot;daniel&quot;]。可索引的类型有一个</code>索引签名<code>，其用于描述我们如何来索引对象中的值，以及说明</code>索引`和返回值的类型。<br>例如:<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">interface</span> StringArray &#123;</div><div class="line">    [index: <span class="built_in">number</span>]: <span class="built_in">string</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> myArray: StringArray;</div><div class="line">myArray = [<span class="string">"Bob"</span>, <span class="string">"Fred"</span>];</div><div class="line"></div><div class="line"><span class="keyword">let</span> myStr: <span class="built_in">string</span> = myArray[<span class="number">0</span>];</div></pre></td></tr></table></figure></p>
<p>这里，我们定义了一个有索引签名的<code>StringArray</code>接口。这个索引签名说明<code>StringArray</code>可用数字来作索引并返回一个<code>string</code>类型的值。</p>
<p>可用作索引的类型有<code>string</code>和<code>number</code>两种。可在同一个接口中使用这两种索引，但是数字索引的返回值类型必须是串索引的<strong>子类型</strong>。这是因为当我们用数字作为索引，JavaScript会把它转换为字符串。即用<code>100</code>作索引实际上和用<code>&quot;100&quot;</code>作索引是同一回事，所以我们需要这两种类型一致。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Animal &#123;</div><div class="line">    name: <span class="built_in">string</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">class</span> Dog <span class="keyword">extends</span> Animal &#123;</div><div class="line">    breed: <span class="built_in">string</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// Error: indexing with a 'string' will sometimes get you an Animal!</span></div><div class="line"><span class="keyword">interface</span> NotOkay &#123;</div><div class="line">    [x: <span class="built_in">number</span>]: Animal;</div><div class="line">    [x: <span class="built_in">string</span>]: Dog;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>注：徦设TypeScript中没有这个限制，那么就会有下面演示的问题</p>
</blockquote>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> notOkey:NotOkay = &#123;&#125;</div><div class="line">notOkey[<span class="number">10</span>]=<span class="keyword">new</span> Animal()</div><div class="line"><span class="comment">//TypeScript 认为notOkey["10"]为Dog，那么就会有潜在的问题</span></div><div class="line">notOkey[<span class="string">"10"</span>]</div></pre></td></tr></table></figure>
<p>尽管串索引是一个强有力的描述<code>字典模式</code>的方式，但它也强制约束了所有属性的类型。这是因为<code>obj.prop</code>和<code>obj[&quot;prop&quot;]</code>是等价的。下面的例子中<code>name</code>和串索引的类型不一致，类型检察器将会给出一个错误。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">interface</span> NumberDictionary &#123;</div><div class="line">    [index: <span class="built_in">string</span>]: <span class="built_in">number</span>;</div><div class="line">    length: <span class="built_in">number</span>;    <span class="comment">// ok, length is a number</span></div><div class="line">    name: <span class="built_in">string</span>;      <span class="comment">// error, the type of 'name' is not a subtype of the indexer</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>最后，你可以让索引是只读的:<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">interface</span> ReadonlyStringArray &#123;</div><div class="line">    readonly [index: <span class="built_in">number</span>]: <span class="built_in">string</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">let</span> myArray: ReadonlyStringArray = [<span class="string">"Alice"</span>, <span class="string">"Bob"</span>];</div><div class="line">myArray[<span class="number">2</span>] = <span class="string">"Mallory"</span>; <span class="comment">// error!</span></div></pre></td></tr></table></figure></p>
<h1 id="类类型"><a href="#类类型" class="headerlink" title="类类型"></a>类类型</h1><h2 id="实现一个接口"><a href="#实现一个接口" class="headerlink" title="实现一个接口"></a>实现一个接口</h2><p>在像C#和Java之类的语言中，接口的一个典型的用法是用来强制类要实现一些方法，TypeScript也可这样用。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">interface</span> ClockInterface &#123;</div><div class="line">    currentTime: <span class="built_in">Date</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">class</span> Clock <span class="keyword">implements</span> ClockInterface &#123;</div><div class="line">    currentTime: <span class="built_in">Date</span>;</div><div class="line">    <span class="keyword">constructor</span>(<span class="params">h: <span class="built_in">number</span>, m: <span class="built_in">number</span></span>) &#123; &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>你也可以在接口中指定成员方法，在类中实现这些方法。<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">interface</span> ClockInterface &#123;</div><div class="line">    currentTime: <span class="built_in">Date</span>;</div><div class="line">    setTime(d: <span class="built_in">Date</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">class</span> Clock <span class="keyword">implements</span> ClockInterface &#123;</div><div class="line">    currentTime: <span class="built_in">Date</span>;</div><div class="line">    setTime(d: <span class="built_in">Date</span>) &#123;</div><div class="line">        <span class="keyword">this</span>.currentTime = d;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">constructor</span>(<span class="params">h: <span class="built_in">number</span>, m: <span class="built_in">number</span></span>) &#123; &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>接口用来描述类的公开部分。</p>
<blockquote>
<p>This prohibits you from using them to check that a class also has particular types for the private side of the class instance.(每个单词都认识，就是不知道它在说什么)</p>
</blockquote>
<h2 id="静态侧类型和实例侧类型的不同之处"><a href="#静态侧类型和实例侧类型的不同之处" class="headerlink" title="静态侧类型和实例侧类型的不同之处"></a>静态侧类型和实例侧类型的不同之处</h2><!--
When working with classes and interfaces, it helps to keep in mind that a class has two types: the type of the static side and the type of the instance side. You may notice that if you create an interface with a construct signature and try to create a class that implements this interface you get an error:
-->
<p>当使用接口和类的时候，需注意的是一个类有两个类型：静态侧类型(type of static side)和实例侧类型（type of instance side）。如果你创建了一个拥有构造函数的签名的接口，并试图用一个类来实现这个接口，那你会得到一个错误：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">interface</span> ClockConstructor &#123;</div><div class="line">    <span class="keyword">new</span> (hour: <span class="built_in">number</span>, minute: <span class="built_in">number</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">class</span> Clock <span class="keyword">implements</span> ClockConstructor &#123;</div><div class="line">    currentTime: <span class="built_in">Date</span>;</div><div class="line">    <span class="keyword">constructor</span>(<span class="params">h: <span class="built_in">number</span>, m: <span class="built_in">number</span></span>) &#123; &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<!--
This is because when a class implements an interface, only the instance side of the class is checked. Since the constructor sits in the static side, it is not included in this check.


Instead, you would need to work with the static side of the class directly. In this example, we define two interfaces, ClockConstructor for the constructor and ClockInterface for the instance methods. Then for convenience we define a constructor function createClock that creates instances of the type that is passed to it.
-->
<p>这是因为当一个类实现一个接口的时候，只有类的实例侧会被检察。而构造函数属于静态侧，而不会被检察。<br>相反，你应该直接使用静态侧类型。在下面这个例子中我们定义了两个接口，用于构造函数的<code>ClockConstructor</code>和用于实例的<code>ClockInterface</code>.然后我们创建了<code>createClock</code>来创建传递给它的的类型的实例。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">interface</span> ClockConstructor &#123;</div><div class="line">    <span class="keyword">new</span> (hour: <span class="built_in">number</span>, minute: <span class="built_in">number</span>): ClockInterface;</div><div class="line">&#125;</div><div class="line"><span class="keyword">interface</span> ClockInterface &#123;</div><div class="line">    tick();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">createClock</span>(<span class="params">ctor: ClockConstructor, hour: <span class="built_in">number</span>, minute: <span class="built_in">number</span></span>): <span class="title">ClockInterface</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ctor(hour, minute);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">class</span> DigitalClock <span class="keyword">implements</span> ClockInterface &#123;</div><div class="line">    <span class="keyword">constructor</span>(<span class="params">h: <span class="built_in">number</span>, m: <span class="built_in">number</span></span>) &#123; &#125;</div><div class="line">    tick() &#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">"beep beep"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">class</span> AnalogClock <span class="keyword">implements</span> ClockInterface &#123;</div><div class="line">    <span class="keyword">constructor</span>(<span class="params">h: <span class="built_in">number</span>, m: <span class="built_in">number</span></span>) &#123; &#125;</div><div class="line">    tick() &#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">"tick tock"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> digital = createClock(DigitalClock, <span class="number">12</span>, <span class="number">17</span>);</div><div class="line"><span class="keyword">let</span> analog = createClock(AnalogClock, <span class="number">7</span>, <span class="number">32</span>);</div></pre></td></tr></table></figure>
<p>因为<code>createClock</code>的第一个参数是<code>ClockConstructor</code>类型，而<code>AnalogClock</code>的构造函数的类型和这个接口是兼容的，所以<code>createClock(AnalogClock,7,32)</code>是可以的。</p>
<h2 id="扩展接口"><a href="#扩展接口" class="headerlink" title="扩展接口"></a>扩展接口</h2><p>和类一样，接口也可以扩展其它的接口。这可以让你把一个接口的属性复制到另外一个接口中。这样就可以把接口拆分成可复用的组件。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">interface</span> Shape &#123;</div><div class="line">    color: <span class="built_in">string</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">interface</span> Square <span class="keyword">extends</span> Shape &#123;</div><div class="line">    sideLength: <span class="built_in">number</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> square = &lt;Square&gt;&#123;&#125;;</div><div class="line">square.color = <span class="string">"blue"</span>;</div><div class="line">square.sideLength = <span class="number">10</span>;</div></pre></td></tr></table></figure>
<p>一个接口可以扩展多个接口：<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">interface</span> Shape &#123;</div><div class="line">    color: <span class="built_in">string</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">interface</span> PenStroke &#123;</div><div class="line">    penWidth: <span class="built_in">number</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">interface</span> Square <span class="keyword">extends</span> Shape, PenStroke &#123;</div><div class="line">    sideLength: <span class="built_in">number</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> square = &lt;Square&gt;&#123;&#125;;</div><div class="line">square.color = <span class="string">"blue"</span>;</div><div class="line">square.sideLength = <span class="number">10</span>;</div><div class="line">square.penWidth = <span class="number">5.0</span>;</div></pre></td></tr></table></figure></p>
<h1 id="混合类型"><a href="#混合类型" class="headerlink" title="混合类型"></a>混合类型</h1><p>就像我们前面提到的那样，接口可以描述JavaScript中的丰富的类型。由于JavaScript的动态性和灵活性，你也许会遇到一个对象，它是好几种类型混合的结果。<br>例如，一个东西既是一个有属性的对象又是一个函数。<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">interface</span> Counter &#123;</div><div class="line">    (start: <span class="built_in">number</span>): <span class="built_in">string</span>;</div><div class="line">    interval: <span class="built_in">number</span>;</div><div class="line">    reset(): <span class="built_in">void</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getCounter</span>(<span class="params"></span>): <span class="title">Counter</span> </span>&#123;</div><div class="line">    <span class="keyword">let</span> counter = &lt;Counter&gt;<span class="function"><span class="keyword">function</span> (<span class="params">start: <span class="built_in">number</span></span>) </span>&#123; &#125;;</div><div class="line">    counter.interval = <span class="number">123</span>;</div><div class="line">    counter.reset = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; &#125;;</div><div class="line">    <span class="keyword">return</span> counter;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> c = getCounter();</div><div class="line">c(<span class="number">10</span>);</div><div class="line">c.reset();</div><div class="line">c.interval = <span class="number">5.0</span>;</div></pre></td></tr></table></figure></p>
<p>当你使用第三方JavaScript库的时候，你也许需要这一特性来完全描述对象的类型。</p>
<h1 id="接口扩展类"><a href="#接口扩展类" class="headerlink" title="接口扩展类"></a>接口扩展类</h1><p>当一个接口扩展只一个类，那么它继承了类的所有成员，但不包含这些成员的实现。表现的就像接口声明了这所有的接口，没有实现它们。接口甚至可以继承一到类的私有的或受保护的成员。这表明当你创建了一个继承了私有或受保护的成员，这个接口就只能被该类的子类实现。(注:原文说的是该接口只能被该类或其子类实现)<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Control &#123;</div><div class="line">    <span class="keyword">private</span> state: <span class="built_in">any</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">interface</span> SelectableControl <span class="keyword">extends</span> Control &#123;</div><div class="line">    select(): <span class="built_in">void</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">class</span> Button <span class="keyword">extends</span> Control <span class="keyword">implements</span> SelectableControl &#123;</div><div class="line">    select() &#123; &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">class</span> TextBox <span class="keyword">extends</span> Control &#123;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// Error: Property 'state' is missing in type 'Image'.</span></div><div class="line"><span class="keyword">class</span> Image <span class="keyword">implements</span> SelectableControl &#123;</div><div class="line">    select() &#123; &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">class</span> Location &#123;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<!--
In the above example, SelectableControl contains all of the members of Control, including the private state property. Since state is a private member it is only possible for descendants of Control to implement SelectableControl. This is because only descendants of Control will have a state private member that originates in the same declaration, which is a requirement for private members to be compatible.

Within the Control class it is possible to access the state private member through an instance of SelectableControl. Effectively, a SelectableControl acts like a Control that is known to have a select method. The Button and TextBox classes are subtypes of SelectableControl (because they both inherit from Control and have a select method), but the Image and Location classes are not.
-->
<p>在上面的例子中，<code>SelectableControl</code>包含了<code>Control</code>的所有成员，包私有的<code>state</code>成员。<code>state</code>是私有变量，只能在<code>Control</code>的子类中实现<code>SelectableControl</code>，这是因为<code>Control</code>的子类才有这些同处声明的私有成员，这是私有成员类型兼容的必要条件。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/10/13/var-declare/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Qianba">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Blogs">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/10/13/var-declare/" itemprop="url">2.变量声明</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-10-13T22:30:02+08:00">
                2017-10-13
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/翻译/" itemprop="url" rel="index">
                    <span itemprop="name">翻译</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/翻译/编程语言/" itemprop="url" rel="index">
                    <span itemprop="name">编程语言</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/翻译/编程语言/TypeScript/" itemprop="url" rel="index">
                    <span itemprop="name">TypeScript</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="变量声明"><a href="#变量声明" class="headerlink" title="变量声明"></a>变量声明</h1><p><code>let</code> 和<code>const</code>是JavaScript中的两种声明方式。就像前文说过的那样，在某些方面<code>let</code>和<code>var</code>是相似的，但是使用<code>let</code>可以避免许多JavaScript程序员常常遇见的陷阱。<code>const</code> 是对<code>let</code>的增强，它可以防止对变量的从新赋值。</p>
<p>TypeScript是JavaScript的超集，所以<code>let</code>和<code>const</code>在TypeScript中自然可用。本文将会仔细介绍这两种声明方式，。。。</p>
<h1 id="var-声明方式"><a href="#var-声明方式" class="headerlink" title="var 声明方式"></a>var 声明方式</h1><p>在JavaScript中一直(注：ES6之前)使用var关键字来声明变量。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var a=10;</div></pre></td></tr></table></figure></p>
<p>就如你所想，这里声明了一个叫<code>a</code>的变量，并且赋值10给它。<br>我们也可以在函数中声明一个变量：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> message = <span class="string">"Hello, world!"</span>;</div><div class="line">    <span class="keyword">return</span> message;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我们也可以在内嵌的其它函数中访问这些变量：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> a = <span class="number">10</span>;</div><div class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">g</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">var</span> b = a + <span class="number">1</span>;</div><div class="line">        <span class="keyword">return</span> b;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> g = f();</div><div class="line">g(); <span class="comment">// returns '11'</span></div></pre></td></tr></table></figure></p>
<p>这段代码中，函数g捕获了变量a，当g被调用的时候，尽管这时候f的调用已经完成了，a都可以被访问，就像f中的代码访问a一样。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> a = <span class="number">1</span>;</div><div class="line"></div><div class="line">    a = <span class="number">2</span>;</div><div class="line">    <span class="keyword">var</span> b = g();</div><div class="line">    a = <span class="number">3</span>;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> b;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">g</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> a;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">f(); <span class="comment">// returns '2'</span></div></pre></td></tr></table></figure></p>
<h1 id="作用域规则"><a href="#作用域规则" class="headerlink" title="作用域规则"></a>作用域规则</h1><p>var 声明方式拥有其它语言没有的奇怪的作用域（注:），举例来说：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">shouldInitialize: boolean</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (shouldInitialize) &#123;</div><div class="line">        <span class="keyword">var</span> x = <span class="number">10</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> x;</div><div class="line">&#125;</div><div class="line"></div><div class="line">f(<span class="literal">true</span>);  <span class="comment">// returns '10'</span></div><div class="line">f(<span class="literal">false</span>); <span class="comment">// returns 'undefined'</span></div></pre></td></tr></table></figure></p>
<p>有些读者对于这个例子可能要多思考两次（即懵一下），变量<code>x</code>在if块中声明，但我们却能在if块的外面访问它（注：在常见的语言中会有一个编译时错误：x 未声明）！导致这一现象的原因是，var 方式声明的变量在其声明所在的函数、模块或全局作用域总是可见的。有人把这称为var作用域或函数作用域。函数参数也是函数作用域。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">sumMatrix</span>(<span class="params">matrix: number[][]</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> sum = <span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; matrix.length; i++) &#123;</div><div class="line">        <span class="keyword">var</span> currentRow = matrix[i];</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; currentRow.length; i++) &#123;</div><div class="line">            sum += currentRow[i];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> sum;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>有了上面的经验，有的读者可能容易看出问题所在。最内的for循环的<code>i</code>覆盖了外层i的值，因为i的作用域在这整个函数！类似的bug不容易在code review时（注：代码审查，开发环节）被发现，而成为问题之源。</p>
<h1 id="变量捕获的怪异行为"><a href="#变量捕获的怪异行为" class="headerlink" title="变量捕获的怪异行为"></a>变量捕获的怪异行为</h1><p>快速指出下列代码的输出：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</div><div class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(i); &#125;, <span class="number">100</span> * i);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>(致不熟悉setTimeout的人：setTimeout会在指定的多少毫秒后执行指定的函数）</p>
<p>答案是什么呢？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">10</div><div class="line">10</div><div class="line">10</div><div class="line">10</div><div class="line">10</div><div class="line">10</div><div class="line">10</div><div class="line">10</div><div class="line">10</div><div class="line">10</div></pre></td></tr></table></figure></p>
<p>许多JavaScript开发人员熟知JavaScript的这一特性，但如果你有些诧异，你也不孤单，因为很多人以为的输出是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">0</div><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td></tr></table></figure></p>
<p>还记得前面提过的变量捕获吗？每一个传递给setTimeout的函数捕获了同作用域下的同一个变量i。<br>让我们稍稍想一下这意味着什么。setTimeout 会在若干毫秒后执行传给它的函数（注：哪怕是setTime(fn,0),请参考《异步JavaScript》）,这时候for循环已经完成，i 是 10。所以，之后运行的函数（setTimeout的回调）输出都是10。</p>
<p>一个常用的解决方案是在每次循环中用<code>立即执行函数表达式(IIFE,Immediately Invoked Function Expression)</code>来捕获<code>i</code><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</div><div class="line">    <span class="comment">// capture the current state of 'i'</span></div><div class="line">    <span class="comment">// by invoking a function with its current value</span></div><div class="line">    (<span class="function"><span class="keyword">function</span>(<span class="params">i</span>) </span>&#123;<span class="comment">//在了的i覆盖了上层作用域的i</span></div><div class="line">        setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(i); &#125;, <span class="number">100</span> * i);</div><div class="line">    &#125;)(i);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这种看起来奇奇怪怪的模式实际上是非常通用的。参数i实际上覆盖了for循环中的i，只是名字相同而矣（注：若理解起来别扭，把IIFE内部的i改成j)。</p>
<blockquote>
<p>如下<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</div><div class="line">    <span class="comment">// capture the current state of 'i'</span></div><div class="line">    <span class="comment">// by invoking a function with its current value</span></div><div class="line">    (<span class="function"><span class="keyword">function</span>(<span class="params">j</span>) </span>&#123;</div><div class="line">        setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(j); &#125;, <span class="number">100</span> * j);</div><div class="line">    &#125;)(i);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
</blockquote>
<h1 id="let-方式声明"><a href="#let-方式声明" class="headerlink" title="let 方式声明"></a><code>let</code> 方式声明</h1><p>现在，你已经知道<code>var</code>的这些问题了，这也正是<code>let</code>被引入的原因，除了关键字不同，两种声明的写法是一样的：<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> hello = <span class="string">"Hello!"</span>;</div></pre></td></tr></table></figure></p>
<p>关键的区别不在于语法，而在于语义——我们即将介绍。</p>
<h1 id="块作用域"><a href="#块作用域" class="headerlink" title="块作用域"></a>块作用域</h1><p>当一个变量用<code>let</code>声明后，它使用所谓的<code>词法作用域</code>（或称<code>块作用域</code>）.不同于<code>var</code> 会将作用域“泄露”到其所在函数，块作用域只在其块内可见，例如for循环体。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">input: <span class="built_in">boolean</span></span>) </span>&#123;</div><div class="line">    <span class="keyword">let</span> a = <span class="number">100</span>;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (input) &#123;</div><div class="line">        <span class="comment">// Still okay to reference 'a'</span></div><div class="line">        <span class="keyword">let</span> b = a + <span class="number">1</span>;</div><div class="line">        <span class="keyword">return</span> b;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// Error: 'b' doesn't exist here</span></div><div class="line">    <span class="keyword">return</span> b;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在段代码中，我们声明了两个变量——a、b，a的作用域在f的函数体内，而b的作用域在if的语句块内。</p>
<p>在catch语句中声明的变量也有自己的块作用域：<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">    <span class="keyword">throw</span> <span class="string">"oh no!"</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">catch</span> (e) &#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"Oh well."</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// Error: 'e' doesn't exist here</span></div><div class="line"><span class="built_in">console</span>.log(e);</div></pre></td></tr></table></figure></p>
<p>块作用域变量的另一个性质是在其声明前是不可以被读写的。（注：有句废话没翻译）</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">a++; <span class="comment">// illegal to use 'a' before it's declared;</span></div><div class="line"><span class="keyword">let</span> a;</div></pre></td></tr></table></figure>
<p>值得注意的是，对于块级变量，你仍可以在声明前捕获它。<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">aFun</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(a);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// illegal call 'foo' before 'a' is declared</span></div><div class="line">    <span class="comment">// runtimes should throw an error here</span></div><div class="line">    <span class="comment">/*</span></div><div class="line"><span class="comment">     * 注：是否有runtime错误要看tsc编译参数，如果编译成ES5及更早版本则没有runtime错误</span></div><div class="line"><span class="comment">     * 请对比（徦设文件名为test.ts）：</span></div><div class="line"><span class="comment">     * tsc -t ES5 test.ts </span></div><div class="line"><span class="comment">     * tsc -t ES2016 test.ts</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    foo();</div><div class="line">    <span class="keyword">let</span> a=<span class="number">1</span>;</div><div class="line">    <span class="keyword">return</span> foo;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="重声明以及覆盖"><a href="#重声明以及覆盖" class="headerlink" title="重声明以及覆盖"></a>重声明以及覆盖</h1><p>上文提及的var方式声明的变量可以在同一作用域被声明多次，而不会报错：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">function f(x) &#123;</div><div class="line">    var x;</div><div class="line">    var x;</div><div class="line"></div><div class="line">    if (true) &#123;</div><div class="line">        var x;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在这个例子中，所有对<code>x</code>的声明都指向了同一个<code>x</code>，这样做的后果常常是成为了bug之源。因此,<code>let</code>不允许这样的声明。<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> x = <span class="number">10</span>;</div><div class="line"><span class="keyword">let</span> x = <span class="number">20</span>; <span class="comment">// error: can't re-declare 'x' in the same scope</span></div></pre></td></tr></table></figure></p>
<p>TypeScript 会告诉我们，同一个块作用域不能有两个同名的变量。<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x</span>) </span>&#123;</div><div class="line">    <span class="keyword">let</span> x = <span class="number">100</span>; <span class="comment">// error: interferes with parameter declaration</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">g</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">let</span> x = <span class="number">100</span>;</div><div class="line">    <span class="keyword">var</span> x = <span class="number">100</span>; <span class="comment">// error: can't have both declarations of 'x'</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>当然如果是父——子作用域是可以的：<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">condition, x</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (condition) &#123;</div><div class="line">        <span class="keyword">let</span> x = <span class="number">100</span>;</div><div class="line">        <span class="keyword">return</span> x;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> x;</div><div class="line">&#125;</div><div class="line"></div><div class="line">f(<span class="literal">false</span>, <span class="number">0</span>); <span class="comment">// returns '0'</span></div><div class="line">f(<span class="literal">true</span>, <span class="number">0</span>);  <span class="comment">// returns '100'</span></div></pre></td></tr></table></figure></p>
<p>这种在子作用域声明一个和父作用域同名的变量的形为就是——变量覆盖（shadowing)。这是一把双刃剑，在“不小心”覆盖了另一个变量的时候就可能会引入一些bug，同时变量覆盖也能访止一些bug，如前面的<code>sumMatrix</code><br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">sumMatrix</span>(<span class="params">matrix: <span class="built_in">number</span>[][]</span>) </span>&#123;</div><div class="line">    <span class="keyword">let</span> sum = <span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; matrix.length; i++) &#123;</div><div class="line">        <span class="keyword">var</span> currentRow = matrix[i];</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; currentRow.length; i++) &#123;</div><div class="line">            sum += currentRow[i];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> sum;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这段代码是能够完成矩阵求和的，因为内层for循环的i覆盖了外层循环的i，那么外层的i就不会被意外的修改了。</p>
<p>在意于写清晰明了的代码的时候应该必免使用变量覆盖这一特性。尽管在有些场合，这一特性会带来一些优势，你最好仔细考量。</p>
<h1 id="块作用域变量捕获"><a href="#块作用域变量捕获" class="headerlink" title="块作用域变量捕获"></a>块作用域变量捕获</h1><p>当我们首次了解var变量的捕获的情况的时候，我们粗略的调查了变量<br>被捕获后的形为。详细说来，每当一个作用域（中的代码）在执行的时候，有一个包含变量的“环境”被创建出来。这个环境和其捕获的变量在其所在的作用域执行完成后依然可以存在！<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">theCityThatAlwaysSleeps</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">let</span> getCity;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (<span class="literal">true</span>) &#123;</div><div class="line">        <span class="keyword">let</span> city = <span class="string">"Seattle"</span>;</div><div class="line">        getCity = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">            <span class="keyword">return</span> city;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> getCity();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>因为我们捕获了<code>city</code>变量，所以在if块执行之后我们仍可以访问它。<br>回想前面<code>setTimeout</code>那个例子，我们需要使用IIFE来捕获变量。<br>实际上，我们创建了一个新的变量环境来捕获变绿。IIFE的方式写起来有些老火，幸运的是在TypeScript中不必那样。<br><code>let</code>方式在循环语句中声明的变量很是不同，除了创建一个新的环境，这类声明（指let和const）也会在每次循环的时候创建一个新的作用域，这正是我们使用IIFE所作的事情。修改一下<code>setTimeout</code>那个例子，使用<code>let</code>来声明变量：<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span> ; i++) &#123;</div><div class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(i); &#125;, <span class="number">100</span> * i);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>输出则入我们所想的那样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">0</div><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td></tr></table></figure></p>
<h1 id="const-声明"><a href="#const-声明" class="headerlink" title="const 声明"></a>const 声明</h1><p>const是声明变量的另一种形式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">const numLivesForCat = 9;</div></pre></td></tr></table></figure></p>
<p>它和let很像，但是，就像其名字所暗示的那样，其值是不能够被修改的。换句话说，<code>const</code>和<code>let</code>具有一样的作用域规则，但是你不能为之重赋值。</p>
<p>可别和<code>不可变（immutable）</code>相混淆：<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> numLivesForCat = <span class="number">9</span>;</div><div class="line"><span class="keyword">const</span> kitty = &#123;</div><div class="line">    name: <span class="string">"Aurora"</span>,</div><div class="line">    numLives: numLivesForCat,</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// Error</span></div><div class="line">kitty = &#123;</div><div class="line">    name: <span class="string">"Danielle"</span>,</div><div class="line">    numLives: numLivesForCat</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">// all "okay"</span></div><div class="line">kitty.name = <span class="string">"Rory"</span>;</div><div class="line">kitty.name = <span class="string">"Kitty"</span>;</div><div class="line">kitty.name = <span class="string">"Cat"</span>;</div><div class="line">kitty.numLives--;</div></pre></td></tr></table></figure></p>
<p>除非你采取了特殊措施，<code>const</code>变量的内部状态（注：对像的属性，数组的元素等）是可变的（注：const 变量指的是引用不变）。所幸，TypeScript可指定属性为<code>readonly</code>来避免属性被修改。<a href="">接口</a>章会详述这个问题。</p>
<h1 id="let-vs-const"><a href="#let-vs-const" class="headerlink" title="let vs. const"></a><code>let</code> vs. <code>const</code></h1><p>设计两种具有相似作用域语义的变量声明方式，这使我们自然会问“使用哪个?”。答案和很多问题一样：看情况。</p>
<p>根据<a href="https://en.wikipedia.org/wiki/Principle_of_least_privilege" target="_blank" rel="external">最少特权原则</a>,所有无计划修改的变量应声明成<code>const</code>。原因是，如果一个变量不需要被修改，那么其头代码也不应有能修改这些变量的能力，也需要思考它们是否真得需要重赋值这些变量。使用<code>const</code>也使的在推算数据流的时候（注：即在脑中执行代码）代码的行为更可被预测。</p>
<p>[placeholder]</p>
<h1 id="解构"><a href="#解构" class="headerlink" title="解构"></a>解构</h1><p>TypeScript拥有的es2015的另一个特性是<code>解构</code>。[这里]是关于解构的完整说明，本节将大略的描述解构。</p>
<h2 id="数组解构"><a href="#数组解构" class="headerlink" title="数组解构"></a>数组解构</h2><p>最简单的数组解构是数组的解构赋值。<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> input = [<span class="number">1</span>, <span class="number">2</span>];</div><div class="line"><span class="keyword">let</span> [first, second] = input;</div><div class="line"><span class="built_in">console</span>.log(first); <span class="comment">// outputs 1</span></div><div class="line"><span class="built_in">console</span>.log(second); <span class="comment">// outputs 2</span></div></pre></td></tr></table></figure></p>
<p>这里创建了两个变量，first和second，和使用索引的方式效果一个，但是更加方便。<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">first = input[<span class="number">0</span>];</div><div class="line">second = input[<span class="number">1</span>];</div></pre></td></tr></table></figure></p>
<p>解构赋值也可使用在已经声明的变量上，<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// swap variables</span></div><div class="line">[first, second] = [second, first];</div></pre></td></tr></table></figure></p>
<p>以及用在函数的参数中：<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">[first, second]: [<span class="built_in">number</span>, <span class="built_in">number</span>]</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(first);</div><div class="line">    <span class="built_in">console</span>.log(second);</div><div class="line">&#125;</div><div class="line">f([<span class="number">1</span>, <span class="number">2</span>]);</div></pre></td></tr></table></figure></p>
<p>你可以使用…语法来创建一个list变量来保存剩余元素：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> [first, ...rest] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</div><div class="line"><span class="built_in">console</span>.log(first); <span class="comment">// outputs 1</span></div><div class="line"><span class="built_in">console</span>.log(rest); <span class="comment">// outputs [ 2, 3, 4 ]</span></div></pre></td></tr></table></figure>
<p>当然，你也可以忽略你不关心的尾部的元素。<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> [first] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</div><div class="line"><span class="built_in">console</span>.log(first); <span class="comment">// outputs 1</span></div></pre></td></tr></table></figure></p>
<p>当然，其它元素也是可忽略的：<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> [, second, , fourth] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</div></pre></td></tr></table></figure></p>
<h2 id="对象解构"><a href="#对象解构" class="headerlink" title="对象解构"></a>对象解构</h2><p>你也可以解构对象：<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> o = &#123;</div><div class="line">    a: <span class="string">"foo"</span>,</div><div class="line">    b: <span class="number">12</span>,</div><div class="line">    c: <span class="string">"bar"</span></div><div class="line">&#125;;</div><div class="line"><span class="keyword">let</span> &#123; a, b &#125; = o;</div></pre></td></tr></table></figure></p>
<p>这里从a对象创建了a、b变量，其值分别是<code>o.a</code>,<code>o.b</code>并忽略了<code>a.c</code>。</p>
<p>和数组解构一样你也可以不要声明而赋值：<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(&#123; a, b &#125; = &#123; a: <span class="string">"baz"</span>, b: <span class="number">101</span> &#125;);</div></pre></td></tr></table></figure></p>
<p>注意，我们必须用园括号把代码包起来，js会把{作为块来解析<br>你也可以使用<code>...</code>语法来创建一个包含其它未被解构属性的变量</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> &#123; a, ...passthrough &#125; = o;</div><div class="line"><span class="keyword">let</span> total = passthrough.b + passthrough.c.length;</div></pre></td></tr></table></figure>
<h3 id="属性重命名"><a href="#属性重命名" class="headerlink" title="属性重命名"></a>属性重命名</h3><p>你也可以给属性一个不同的名字<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> &#123; a: newName1, b: newName2 &#125; = o;</div></pre></td></tr></table></figure></p>
<p>这种语法开始让人有点迷糊，你可以把<code>a:newName1</code>解释为<code>newName1是a</code>,这和下面的代码是等价的：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> newName1 = o.a;</div><div class="line"><span class="keyword">let</span> newName2 = o.b;</div></pre></td></tr></table></figure>
<p>这里的<code>：</code>不是表示类型，如果你想指定变量的类型，那么需要在整个解构后。</p>
<h3 id="默认值"><a href="#默认值" class="headerlink" title="默认值"></a>默认值</h3><p>默认值可以在某个属性是undefined的时候指定一个默认的值。<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">keepWholeObject</span>(<span class="params">wholeObject: &#123; a: <span class="built_in">string</span>, b?: <span class="built_in">number</span> &#125;</span>) </span>&#123;</div><div class="line">    <span class="keyword">let</span> &#123; a, b = <span class="number">1001</span> &#125; = wholeObject;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里,在函数<code>keepWholeObject</code>中有变量:<code>a</code>,<code>b</code>,以及<code>wholeObject</code>。</p>
<h3 id="函数声明"><a href="#函数声明" class="headerlink" title="函数声明"></a>函数声明</h3><p>解构也可用在函数的声明中，如下例：<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> C = &#123; a: <span class="built_in">string</span>, b?: <span class="built_in">number</span> &#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">&#123; a, b &#125;: C</span>): <span class="title">void</span> </span>&#123;</div><div class="line">    <span class="comment">// ...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>[placeholder]</p>
<h2 id="延展"><a href="#延展" class="headerlink" title="延展"></a>延展</h2><blockquote>
<p>不知道spread对应的术语，乱译为<code>延展</code></p>
</blockquote>
<p>spread运算和解构运算作用是相对的，它可以把一个数组中的元素放到其他数组中。或者把一个对象的属性放到其它对象中。<br>比如：<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> first = [<span class="number">1</span>, <span class="number">2</span>];</div><div class="line"><span class="keyword">let</span> second = [<span class="number">3</span>, <span class="number">4</span>];</div><div class="line"><span class="keyword">let</span> bothPlus = [<span class="number">0</span>, ...first, ...second, <span class="number">5</span>];</div></pre></td></tr></table></figure></p>
<p><code>bothPlus</code>数组为[0,1,2,3,4,5],<code>Spread</code>创建了<code>first</code>和<code>second</code>的<strong>浅拷贝</strong><br>你也可以<code>spread</code>一个对象<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> defaults = &#123; food: <span class="string">"spicy"</span>, price: <span class="string">"$$"</span>, ambiance: <span class="string">"noisy"</span> &#125;;</div><div class="line"><span class="keyword">let</span> search = &#123; ...defaults, food: <span class="string">"rich"</span> &#125;;</div></pre></td></tr></table></figure></p>
<p><code>search</code>为<code>{ food: &quot;rich&quot;, price: &quot;$$&quot;, ambiance: &quot;noisy&quot; }</code>,对象的延展比数组的延展要复杂一些。和数组延展一样，处理的过程是“从左到右的”,只是处理的结果仍然是一个数组而矣。这意味着，后出现的属性将覆盖先出现的属性。所以，如果我们修改上面的例子：<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> defaults = &#123; food: <span class="string">"spicy"</span>, price: <span class="string">"$$"</span>, ambiance: <span class="string">"noisy"</span> &#125;;</div><div class="line"><span class="keyword">let</span> search = &#123; food: <span class="string">"rich"</span>, ...defaults &#125;;</div></pre></td></tr></table></figure></p>
<p>那么得到的search的food属性的值将会是<code>spicy</code>。</p>
<p>对象延展还有一些限制，结果只会包含对象<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Enumerability_and_ownership_of_properties" target="_blank" rel="external">自身的、可枚举的属性</a>(注：自身的表示非原型链上的属性)<br>所以，当你延展一个对象时，将丢失其上的方法。<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> C &#123;</div><div class="line">  p = <span class="number">12</span>;</div><div class="line">  m() &#123;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">let</span> c = <span class="keyword">new</span> C();</div><div class="line"><span class="keyword">let</span> clone = &#123; ...c &#125;;</div><div class="line">clone.p; <span class="comment">// ok</span></div><div class="line">clone.m(); <span class="comment">// error!</span></div></pre></td></tr></table></figure></p>
<p>此外，Typescript编译器不允许泛型函数的类型参数。这一特型在将来的版本中可能会受支持。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/10/10/bacis-types/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Qianba">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Blogs">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/10/10/bacis-types/" itemprop="url">1.基本类型</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-10-10T17:32:03+08:00">
                2017-10-10
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/翻译/" itemprop="url" rel="index">
                    <span itemprop="name">翻译</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/翻译/编程语言/" itemprop="url" rel="index">
                    <span itemprop="name">编程语言</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/翻译/编程语言/TypeScript/" itemprop="url" rel="index">
                    <span itemprop="name">TypeScript</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Boolean"><a href="#Boolean" class="headerlink" title="Boolean"></a>Boolean</h1><p>最基本的数据类型为简单的true/false值，在TypeScript中被称为<code>boolean</code> 值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">let isDone:boolean = false;</div></pre></td></tr></table></figure></p>
<h1 id="Number"><a href="#Number" class="headerlink" title="Number"></a>Number</h1><p>和JavaScript 一样，所有数字都是浮点数，即<code>number</code>类型<br>除了十六进制和十进制字面量，TypeScript也支持ECMAScript 2015引入的二进制和八进制字面量</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> decimal: <span class="built_in">number</span> = <span class="number">6</span>;</div><div class="line"><span class="keyword">let</span> hex: <span class="built_in">number</span> = <span class="number">0xf00d</span>;</div><div class="line"><span class="keyword">let</span> binary: <span class="built_in">number</span> = <span class="number">0b1010</span>;</div><div class="line"><span class="keyword">let</span> octal: <span class="built_in">number</span> = <span class="number">0o744</span>;</div></pre></td></tr></table></figure>
<h1 id="String"><a href="#String" class="headerlink" title="String"></a>String</h1><p>在JavaScript中，编写程序的一项基本工作是对文本数据的处理。和其它的语言一样，我们使用<code>string</code>来表示这些文本数据类型。和JavaScript一样，TypeScript也使用双引号和单引号来表示字符串数据。<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> color: <span class="built_in">string</span> = <span class="string">"blue"</span>;</div><div class="line">color = <span class="string">'red'</span>;</div></pre></td></tr></table></figure></p>
<p>你也可以使用<code>模版字符串</code>,在模版字符串中可以嵌入表达式，同时，模版串内可以换行。模版串用反引号来表示，其内嵌的表达式形如<code>${ expression }</code></p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> fullName: <span class="built_in">string</span> = <span class="string">`Bob Bobbington`</span>;</div><div class="line"><span class="keyword">let</span> age: <span class="built_in">number</span> = <span class="number">37</span>;</div><div class="line"><span class="keyword">let</span> sentence: <span class="built_in">string</span> = <span class="string">`Hello, my name is <span class="subst">$&#123; fullName &#125;</span>.</span></div><div class="line"><span class="string"></span></div><div class="line"><span class="string">I'll be <span class="subst">$&#123; age + 1 &#125;</span> years old next month.`</span>;</div></pre></td></tr></table></figure>
<p>这和按如下方式定义<code>sentence</code> 等价：<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> sentence: <span class="built_in">string</span> = <span class="string">"Hello, my name is "</span> + fullName + <span class="string">".\n\n"</span> +</div><div class="line">    <span class="string">"I'll be "</span> + (age + <span class="number">1</span>) + <span class="string">" years old next month."</span>;</div></pre></td></tr></table></figure></p>
<h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><p>和JavaScript一样，TypeScript允许你使用数组。数组的类型可有两种写法。<br>第一种是在元素类型的后面跟上一对方括号：<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> list:<span class="built_in">number</span>[] = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</div></pre></td></tr></table></figure></p>
<p>第二种是使用泛型数组参数:<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> list:<span class="built_in">Array</span>&lt;<span class="built_in">number</span>&gt; = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</div></pre></td></tr></table></figure></p>
<h1 id="元组-Tuple"><a href="#元组-Tuple" class="headerlink" title="元组(Tuple)"></a>元组(Tuple)</h1><p>一个数组元素个数固定且类型已知，用元组来表示。例如，你可能需要表示一个<code>string</code>和一个<code>number</code>构成的二元组<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Declare a tuple type</span></div><div class="line"><span class="keyword">let</span> x: [<span class="built_in">string</span>, <span class="built_in">number</span>];</div><div class="line"><span class="comment">// Initialize it</span></div><div class="line">x = [<span class="string">"hello"</span>, <span class="number">10</span>]; <span class="comment">// OK</span></div><div class="line"><span class="comment">// Initialize it incorrectly</span></div><div class="line">x = [<span class="number">10</span>, <span class="string">"hello"</span>]; <span class="comment">// Error</span></div></pre></td></tr></table></figure></p>
<p>当我们访问一个索引已知的元组元素，那么这个元素的类型也就是已知的了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">console.log(x[0].substr(1)); // OK</div><div class="line">console.log(x[1].substr(1)); // Error, &apos;number&apos; does not have &apos;substr&apos; typescript 知道x[1]是一个number类型的东西</div></pre></td></tr></table></figure></p>
<p>当访问元组索引范围外的元素的时候，TypeScript会将其视为该元组已知类型的<code>并类型(Union types)</code>.<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">x[<span class="number">3</span>] = <span class="string">"world"</span>; <span class="comment">// OK, 'string' can be assigned to 'string | number'</span></div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(x[<span class="number">5</span>].toString()); <span class="comment">// OK, 'string' and 'number' both have 'toString'</span></div><div class="line"></div><div class="line">x[<span class="number">6</span>] = <span class="literal">true</span>; <span class="comment">// Error, 'boolean' isn't 'string | number'</span></div></pre></td></tr></table></figure></p>
<p>并类型是一个高级话题，将在后文讨论。</p>
<h1 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h1><p>除了JavaScript的数据类型，TypeScript还增加了一种有用的类型——枚举(enum). 和C#一样，枚举是给一组数字取一个友好的名字的方式。（注: typescript 2.4 中枚举也可以是字符串)<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">enum</span> Color &#123;Red, Green, Blue&#125;</div><div class="line"><span class="keyword">let</span> c: Color = Color.Green;</div></pre></td></tr></table></figure></p>
<p>默认情况下，枚举值从0开始(后续加1)。你可以手动为枚举的某个成员设置一个值来改变其默认的值。<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">enum</span> Color &#123;Red = <span class="number">1</span>, Green, Blue&#125; </div><div class="line"><span class="keyword">let</span> c: Color = Color.Green; <span class="comment">// 2</span></div></pre></td></tr></table></figure></p>
<p>或者，可以为枚举的每个成员设置值。<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">enum</span> Color &#123;Red = <span class="number">1</span>, Green = <span class="number">2</span>, Blue = <span class="number">4</span>&#125;</div><div class="line"><span class="keyword">let</span> c: Color = Color.Green;</div></pre></td></tr></table></figure></p>
<p>一个方便的特性是你根据枚举值得到其对应的名字.<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">enum</span> Color &#123;Red = <span class="number">1</span>, Green, Blue&#125;</div><div class="line"><span class="keyword">let</span> colorName: <span class="built_in">string</span> = Color[<span class="number">2</span>];</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(colorName); <span class="comment">// Green</span></div></pre></td></tr></table></figure></p>
<h1 id="Any-类型"><a href="#Any-类型" class="headerlink" title="Any 类型"></a>Any 类型</h1><p>我们也许需要描述这样一种变量——我们在写程序的时候并不知道其类型，这些变量值可能来自一些动态的内容，例如——第三方库。这种情况，我们想对这些变量停用类型检察以便通过编译。为了做到这点，我们使用<code>any</code> 类型<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> notSure: <span class="built_in">any</span> = <span class="number">4</span>;</div><div class="line">notSure = <span class="string">"maybe a string instead"</span>;</div><div class="line">notSure = <span class="literal">false</span>; <span class="comment">// okay, definitely a boolean</span></div></pre></td></tr></table></figure></p>
<p>any 类型是和JavaScript库交互的有效方式，这可让你逐渐的启用或停用类型检察。你也许希望<code>Object</code>类现会扮演同样的角色，在其它某些语言中的却如此。但在typescript中，Object类型的变量只允许你将any类型的变量赋值给它，而不能调用上面的任意方法，那怕是的确存在的方法。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> notSure: <span class="built_in">any</span> = <span class="number">4</span>;</div><div class="line">notSure.ifItExists(); <span class="comment">// okay, ifItExists might exist at runtime</span></div><div class="line">notSure.toFixed(); <span class="comment">// okay, toFixed exists (but the compiler doesn't check)</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> prettySure: <span class="built_in">Object</span> = <span class="number">4</span>;</div><div class="line">prettySure.toFixed(); <span class="comment">// Error: Property 'toFixed' doesn't exist on type 'Object'.</span></div></pre></td></tr></table></figure>
<h1 id="Void-类型"><a href="#Void-类型" class="headerlink" title="Void 类型"></a>Void 类型</h1><p>void有些像是和any相反，它表示——没有类型。你可能常在函数的返回值类型声明的地方见到该类型。<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">warnUser</span>(<span class="params"></span>): <span class="title">void</span> </span>&#123;</div><div class="line">    alert(<span class="string">"This is my warning message"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>用void来声明变量就没什么意义了，因为你只能给它赋<code>undefined</code>或<code>null</code>给它。</p>
<h1 id="Null-和-Undefined"><a href="#Null-和-Undefined" class="headerlink" title="Null 和 Undefined"></a>Null 和 Undefined</h1><p>默认情况下，null和undefined 是所有其它类型的子类型，所以null和undefined可以赋值给任何变量。<br>但当<code>--strictNullChecks</code>选项启用后，null和undefined就只能够赋值给<code>void</code>或其对应的类型（注：null，undefined 即是类型，也是值）。这有助于避免多数常见错误。<br>当你希望传递string或null或undefined的类型的值的时候则需要使用并类型 <code>string | null | undefined</code>。</p>
<blockquote>
<p>推荐使用<code>--strictNullChecks</code>,但该教程徦设该选项是关闭了的。</p>
</blockquote>
<h1 id="Never-类型"><a href="#Never-类型" class="headerlink" title="Never 类型"></a>Never 类型</h1><p>never 类型代表了“<code>永远不会出现</code>”的类型，<code>never</code> 是那些总是抛出错误或永不返回的函数的“返回类型”()。<br>(Variables also acquire the type never when narrowed by any type guards that can never be true. ???)<br>never 类型也是所有类型的子类型，同时，没有类型是never类型的子类型，所以除了never自己，没有类型可以赋值给never。 any也不可以赋值给never。<br>函数返回类型为<code>never</code>的例子：<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Function returning never must have unreachable end point</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">error</span>(<span class="params">message: <span class="built_in">string</span></span>): <span class="title">never</span> </span>&#123;</div><div class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(message);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// Inferred return type is never</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">fail</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> error(<span class="string">"Something failed"</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// Function returning never must have unreachable end point</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">infiniteLoop</span>(<span class="params"></span>): <span class="title">never</span> </span>&#123;</div><div class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="类型断言"><a href="#类型断言" class="headerlink" title="类型断言"></a>类型断言</h1><p>有时候你会遇到这样的情况：你比TypeScript更清楚一个值是什么类型的。<br>类型断言是一种指定类型的方法，相当于告诉编译器：“相信我，我知道为在做什么”。类型断言和其它语言中的类型转换(type cast)是类似的，但不会执行特别的检察或数据重构操作。也没有运行时的开销，只是纯粹的为编译器使用而矣。TypeScript徦设你已经做过必要的检察了。<br>类型断言有两种形式，一种是<code>尖括号</code>语法:<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> someValue: <span class="built_in">any</span> = <span class="string">"this is a string"</span>;</div><div class="line"></div><div class="line"><span class="keyword">let</span> strLength: <span class="built_in">number</span> = (&lt;<span class="built_in">string</span>&gt;someValue).length;</div></pre></td></tr></table></figure></p>
<p>另一种是<code>as</code>语法：<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">    <span class="keyword">let</span> someValue: <span class="built_in">any</span> = <span class="string">"this is a string"</span>;</div><div class="line"></div><div class="line"><span class="keyword">let</span> strLength: <span class="built_in">number</span> = (someValue <span class="keyword">as</span> <span class="built_in">string</span>).length;</div></pre></td></tr></table></figure></p>
<p>这两种方式是等价的，使用哪种取决于你的偏好。但是，如果在TypeScript中使用JSX, 则只有<code>as</code>方式是可用的（注：JSX 用尖括号了表示组件，这会引入二意性）。</p>
<h1 id="关于-let"><a href="#关于-let" class="headerlink" title="关于 let"></a>关于 <code>let</code></h1><p>你可能注意到了，我们使用<code>let</code>关键字代替了JavaScript中的<code>var</code>关键字。let 实际上是JavaScript 新标准的东西，TypeScript使其提前可用了。后面我们会进一步讨论let，let可以缓解JavaScript中的很多问题，所以，尽可能使用let来代替var吧！</p>
<h1 id="进一步阅读"><a href="#进一步阅读" class="headerlink" title="进一步阅读"></a>进一步阅读</h1><p><a href="https://stackoverflow.com/questions/37910669/what-is-the-difference-between-never-and-void-in-typescript" target="_blank" rel="external">never 和 void 的区别</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  


          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="Qianba" />
          <p class="site-author-name" itemprop="name">Qianba</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">3</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              
                <span class="site-state-item-count">3</span>
                <span class="site-state-item-name">分类</span>
              
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              
                <span class="site-state-item-count">1</span>
                <span class="site-state-item-name">标签</span>
              
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Qianba</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.2"></script>



  
  

  
    <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.2"></script>

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.2"></script>



  


  




	





  





  






  





  

  

  

  

  

  

</body>
</html>
